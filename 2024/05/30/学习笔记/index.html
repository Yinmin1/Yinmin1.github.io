<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>学习笔记 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="上传文章命令：hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 快捷键使用方法Ctrl+1 ——设置一级标题 Ctrl+2 ——设置二级标题 Ctrl+3 ——设置三级标题 Ctrl+4 ——设置四级标题 Ctrl+5 ——设置五级标题 Ctrl+6 ——设置六级标题 &gt; + 空格 ——引用 回车、shift + tab —">
<meta property="og:type" content="article">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="http://example.com/2024/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="上传文章命令：hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 快捷键使用方法Ctrl+1 ——设置一级标题 Ctrl+2 ——设置二级标题 Ctrl+3 ——设置三级标题 Ctrl+4 ——设置四级标题 Ctrl+5 ——设置五级标题 Ctrl+6 ——设置六级标题 &gt; + 空格 ——引用 回车、shift + tab —">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-05-30T10:00:00.000Z">
<meta property="article:modified_time" content="2024-06-08T08:00:23.814Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-08 16:00:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-30T10:00:00.000Z" title="Created 2024-05-30 18:00:00">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-08T08:00:23.814Z" title="Updated 2024-06-08 16:00:23">2024-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>上传文章命令：hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</p>
<h1 id="快捷键使用方法"><a href="#快捷键使用方法" class="headerlink" title="快捷键使用方法"></a>快捷键使用方法</h1><p>Ctrl+1 ——设置一级标题</p>
<p>Ctrl+2 ——设置二级标题</p>
<p>Ctrl+3 ——设置三级标题</p>
<p>Ctrl+4 ——设置四级标题</p>
<p>Ctrl+5 ——设置五级标题</p>
<p>Ctrl+6 ——设置六级标题</p>
<p><strong>&gt; + 空格</strong> ——引用</p>
<p>回车、shift + tab ——退出引用</p>
<p>Ctrl + Shift + ] ——无序列表</p>
<p>Ctrl + Shift + [ ——有序列表</p>
<p>Ctrl + Shift + ] 、tab——子列表</p>
<p>Shift + tab ——返回上一级列表</p>
<p>Ctrl + B —— 加粗</p>
<p>Ctrl + T —— 表格<br><strong>~~~</strong> ——代码块</p>
<p><strong>~ ~ 要删除的内容 ~ ~</strong> ——删除线</p>
<p>maven仓库手动添加</p>
<p>mvn install:install-file -Dfile&#x3D;.jar -DgroupId&#x3D;  -DartifactId&#x3D; -Dversion&#x3D; -Dpackaging&#x3D;jar</p>
<h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>格式为[] ()，其中[]内为要展示的内容，()为链接。</p>
<p><strong>&#x3D;&#x3D; 内容&#x3D;&#x3D;</strong> —— 高亮</p>
<p><strong>~~~</strong> ——代码块，点击代码框可选择语言</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>逻辑结构：集合关系，线性关系，树形关系，图结构</p>
<p>存储结构：顺序存储，链式存储，索引存储，散列存储</p>
<img src="F:\Typora\img\image-20240129214329898.png" alt="image-20240129214329898" style="zoom:67%;" />

<p>数组</p>
<p>链表：单向，双向和环形链表，约瑟夫环问题</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先进后出</p>
<p><img src="F:\Typora\img\wps4.jpg" alt="img"></p>
<p><img src="F:\Typora\img\wps1.jpg" alt="img"></p>
<p><img src="F:\Typora\img\wps2.jpg" alt="img"></p>
<p>栈实现表达式的计算思路：创建两个栈，一个为数栈一个为符号栈，当符号栈为空时直接进栈，若符号栈不为空，符号进栈需比较与栈顶符号的优先级，若优先级小于等于栈顶符号则从数栈pop出两个数字，从符号栈pop出一个符号进行运算，然后将结果保存到数栈，再将当前符号进栈；如果优先级大则直接进栈。</p>
<p>对于多位数，需要对数字的下一位进行判断是否仍为数字</p>
<h3 id="栈的经典应用"><a href="#栈的经典应用" class="headerlink" title="栈的经典应用"></a>栈的经典应用</h3><p>栈在括号中的应用</p>
<p>遇到左括号就入栈，遇到右括号就消耗一个左括号</p>
<p>最先进入的左括号最后出栈</p>
<p>栈的表达式求值</p>
<p>前缀，中缀，后缀表达式</p>
<p>中缀转后缀，采用“左优先”原则：即左边的运算符能先计算，就先算左边的，可保证运算顺序唯一</p>
<p>从左往右遍历，创建一个数字栈和一个符号栈</p>
<p>当遍历到数字时，直接进入数字栈</p>
<p>当遍历到左括号时，直接入符号栈</p>
<p>当遍历到右括号时，依次弹出符号栈的符号，直到弹出左括号，然后舍弃这对左右括号</p>
<p>当遍历到符号时，若符号栈为空，或者当前符号的优先级大于栈顶符号的优先级，或者栈顶符号为左括号时，直接入栈</p>
<p>若当前符号的优先级小于等于栈顶符号的优先级时，将栈顶符号弹出并压入数字栈，当前符号与新的栈顶符号比较，直至入栈</p>
<p>后缀的计算方法：</p>
<p>准备一个数字栈，从左往右遍历</p>
<p>遍历到数字则进入数字栈，遍历到运算符则弹出两个数字如a，b，假如当前运算符为-，则a-b进行运算，然后将结果重新进入数字栈</p>
<p>重复该流程直至遍历完，此时栈剩一个数字，即为结果</p>
<p>将上述两个算法结合起来，即可实现中缀表达式的计算</p>
<p>在中缀转后缀时，每弹出一个符号就弹出两个数字进行运算，并将结果重新压入数字栈</p>
<p>中缀转前缀则采用右优先原则，从右往左遍历</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><img src="F:\Typora\img\wps3.jpg" alt="img"></p>
<p><img src="F:\Typora\img\wps5.jpg" alt="img"><img src="F:\Typora\img\wps6.jpg" alt="img"></p>
<h3 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h3><p>树的层次遍历，图的广度优先遍历等</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p> 串：即字符串</p>
<h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p>即暴力破解</p>
<p>选择与模式串（即想要搜索的目标串）的长度，然后从头开始进行对比</p>
<p>如果当前子串不一致，则头结点往后移动一位继续进行对比</p>
<h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><p>创建int i &#x3D; 1. int j &#x3D; 1 </p>
<p>主串指针i不回溯，模式串指针j回溯</p>
<p>先对模式串进行分析，获得去对应的next数组</p>
<p>next数组用于当模式串与子串不一致时，模式串对应的j应回到什么位置</p>
<p>预留了一个next[1] &#x3D; 0</p>
<p>是为了当子串和模式串的第一个字符不一致时，使得i和j同时向后移动一位，</p>
<p>next数组剩下的值需要看对应的模式串进行分析</p>
<h4 id="串的前缀和后缀"><a href="#串的前缀和后缀" class="headerlink" title="串的前缀和后缀"></a>串的前缀和后缀</h4><p>前缀：包含第一个字符，且不包含最后一个字符的子串</p>
<p>后缀：包含最后一个字符，且不包含第一个字符的子串</p>
<p>如假设abababc，在j&#x3D;7，即c的位置匹配失败</p>
<p>则1~j-1个字符组成的串记为S，next[j] &#x3D; S的最长相等前后缀+1</p>
<p>如S为ababab，最长相等前后缀为4</p>
<p>因此next[7] &#x3D; 5</p>
<p>对于abcde，在e处匹配失败</p>
<p>则对串abcd进行分析</p>
<p>前缀与后缀分别取0,1,2,3都对应不上</p>
<p>则最长相等前后缀为0，next[5] &#x3D; 1</p>
<p>特别地，next[1] &#x3D; 0，理由上面说了，为了i和j同时加1</p>
<p> 多次分析得出，next[2] &#x3D; 1，从j&#x3D;3的位置开始继续分析即可</p>
<img src="F:\Typora\img\image-20240302171234302.png" alt="image-20240302171234302" style="zoom:67%;" />

<h4 id="next数组与kmp算法代码"><a href="#next数组与kmp算法代码" class="headerlink" title="next数组与kmp算法代码"></a>next数组与kmp算法代码</h4><img src="F:\Typora\img\image-20240302171341941.png" alt="image-20240302171341941" style="zoom:67%;" />

<h4 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h4><p>next[1]即模式串指针的第一个字符</p>
<p>next里下标不是从0开始的， next[0]是一个特殊的位置，因为j是从1开始的，所以next也要从1开始</p>
<p>如果是从0开始，记得重新分析一下坐标的对应关系</p>
<p>第i个字符对应的是next[i]</p>
<h4 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h4><p>当模式串发生匹配失败时，若匹配失败的字符与回溯后的位置对应的字符一致，此时此次返回后的位置，会因为当前字符与原来的字符一致而导致因此匹配再次失败，再次回溯</p>
<p>因此我们可以直接将回溯的位置定为回溯后的字符，匹配失败时需要回溯的位置</p>
<img src="F:\Typora\img\image-20240302222325021.png" alt="image-20240302222325021" style="zoom:67%;" />

<p>如图所示，当在第5个字符b处发生匹配失败时</p>
<p>其最长前后缀为a，返回位置为1+1&#x3D;2</p>
<p>而第2个位置对应的字符又是b，再次匹配失败，再次回溯到1</p>
<p>因此我们不妨设置一个判断，若当前字符与回溯后的字符一样</p>
<p>则next[j] &#x3D; 回溯后的字符对应的next[j]</p>
<p>如果不相等，则保存原来的next[j]</p>
<img src="F:\Typora\img\image-20240302222738498.png" alt="image-20240302222738498" style="zoom:67%;" />











<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>方法自己调用自己，但每次调用传入不同的变量</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><img src="F:\Typora\img\image-20240302230932292.png" alt="image-20240302230932292" style="zoom:67%;" />



<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>结点的度：结点有几个孩子</p>
<p>结点数 &#x3D; 总度数 + 1</p>
<img src="F:\Typora\img\image-20240303121633433.png" alt="image-20240303121633433" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303121959140.png" alt="image-20240303121959140" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303122102155.png" alt="image-20240303122102155" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303122127644.png" alt="image-20240303122127644" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303122301177.png" alt="image-20240303122301177" style="zoom:67%;" />

<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>顺序存储，利用数组进行存储，保存父结点在数组中的位置</p>
<p>如果删除叶子结点相对简单，但如果删除某棵子树的根结点</p>
<p>则还需要删除以这结点为根的子树的孩子结点，但因为没记录孩子结点</p>
<p>只能从头遍历找到这个根结点的孩子结点，非常慢</p>
<img src="F:\Typora\img\image-20240304092654927.png" alt="image-20240304092654927" style="zoom:67%;" />

<p>利用数组保留各个结点的位置，然后利用链表来保留各个结点的孩子结点，找孩子结点方便，但找父结点则麻烦</p>
<img src="F:\Typora\img\image-20240304093134827.png" alt="image-20240304093134827" style="zoom:67%;" />

<p>最重要，如果只有一个孩子结点，则firstchild直接指向该孩子结点，如果有多个孩子结点，则firstchild指向第一个左孩子结点</p>
<p>nextsibling则指向该结点右边的第一个兄弟结点</p>
<p>这样就实现了树与二叉树的转化</p>
<img src="F:\Typora\img\image-20240304093723237.png" alt="image-20240304093723237" style="zoom:67%;" />

<p>森林与二叉树的转换也是同理</p>
<p>先对每一个树进行转换为二叉树，然后从左往右，将第一棵树的右兄弟结点指向第二棵树，直到最后一棵树</p>
<p>根结点的右兄弟结点这条线的结点，都是每一棵树的根结点</p>
<img src="F:\Typora\img\image-20240304093905362.png" alt="image-20240304093905362" style="zoom:67%;" />





<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><img src="F:\Typora\img\image-20240303123501245.png" alt="image-20240303123501245" style="zoom:67%;" />

<h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><img src="F:\Typora\img\image-20240303124012775.png" alt="image-20240303124012775" style="zoom:67%;" />

<p>满二叉树是一种特殊的完全二叉树</p>
<p>完全二叉树的叶子结点必须是从左往右的，如果有一个节点只有一个孩子，则一定是左孩子</p>
<img src="F:\Typora\img\image-20240303124244318.png" alt="image-20240303124244318" style="zoom:67%;" />

<p>二叉排序树可用于元素的排序和搜索</p>
<img src="F:\Typora\img\image-20240303124607394.png" alt="image-20240303124607394" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303124624803.png" alt="image-20240303124624803" style="zoom:67%;" />

<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="二叉树的常考性质"><a href="#二叉树的常考性质" class="headerlink" title="二叉树的常考性质"></a>二叉树的常考性质</h4><img src="F:\Typora\img\image-20240303124920143.png" alt="image-20240303124920143" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303124948123.png" alt="image-20240303124948123" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303125003440.png" alt="image-20240303125003440" style="zoom:67%;" />



<h4 id="完全二叉树的常考性质"><a href="#完全二叉树的常考性质" class="headerlink" title="完全二叉树的常考性质"></a>完全二叉树的常考性质</h4><img src="F:\Typora\img\image-20240303125217934.png" alt="image-20240303125217934" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303125418222.png" alt="image-20240303125418222" style="zoom:67%;" />



<img src="F:\Typora\img\image-20240303125438999.png" alt="image-20240303125438999" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303125622375.png" alt="image-20240303125622375" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303125637988.png" alt="image-20240303125637988" style="zoom:67%;" />

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>分为顺序存储和链式存储</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><img src="F:\Typora\img\image-20240303144047190.png" alt="image-20240303144047190" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240303144315018.png" alt="image-20240303144315018" style="zoom:67%;" />

<p>如果不是一棵完全二叉树，然后又按照层序将各结点顺序存储，此时无法从结点编号中反映出结点间的逻辑关系</p>
<p>如果还是想要顺序存储，需在没有孩子结点的地方空出位置</p>
<img src="F:\Typora\img\image-20240303144639137.png" alt="image-20240303144639137" style="zoom:67%;" />

<p>需要根据isEmpty这个变量来判断是否是一个空结点</p>
<p>最坏的情况：高度为h且只有h个结点的单职树，至少需要2^h - 1个存储单元，浪费空间</p>
<p>结论：二叉树的顺序存储结构，只适合存储完全二叉树</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><img src="F:\Typora\img\image-20240303145046388.png" alt="image-20240303145046388" style="zoom:67%;" />

<p>如果为了方便找到父结点，需要在类中再添加一个指向父结点的变量</p>
<p>存指针而不是存结点</p>
<h3 id="先中后序遍历"><a href="#先中后序遍历" class="headerlink" title="先中后序遍历"></a>先中后序遍历</h3><p>先序遍历：根左右</p>
<p>中序遍历：左根右</p>
<p>后序遍历：左右根</p>
 <img src="F:\Typora\img\image-20240303145944979.png" alt="image-20240303145944979" style="zoom:67%;" />

<p>如果只给出一棵二叉树的一种遍历序列，我们并不能唯一地确定一棵二叉树</p>
<p>期末需要给出一种不同的遍历序列配合上&#x3D;&#x3D;中序&#x3D;&#x3D;遍历序列，我们才能唯一确定一棵树</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>即一层一层地遍历 </p>
<img src="F:\Typora\img\image-20240303151542071.png" alt="image-20240303151542071" style="zoom:67%;" />

<p>当队列非空时，则弹出一个结点，并将其左右孩子入队</p>
<img src="F:\Typora\img\image-20240303151715336.png" alt="image-20240303151715336" style="zoom:67%;" />



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>中序遍历存在的缺陷：我们每次遍历都要从根结点出发，没法随机指定一个结点，从这个结点开始中序遍历</p>
<p>一个指定的结点也没办法找到其在中序遍历中的前一个结点，以及后一个结点</p>
<img src="F:\Typora\img\image-20240303164624733.png" alt="image-20240303164624733" style="zoom:67%;" />

<p>因此导致了中序线索二叉树的诞生</p>
<p>利用叶子结点其左右孩子为空的情况，将结点的左右孩子分别指向其在中序遍历中的前驱和后继结点</p>
<img src="F:\Typora\img\image-20240303165047034.png" alt="image-20240303165047034" style="zoom:67%;" />

<p>指向前驱后继的指针（结点）被称为“线索”</p>
<img src="F:\Typora\img\image-20240303165543312.png" alt="image-20240303165543312" style="zoom:67%;" />

<p>先序线索二叉树和后序线索二叉树与中序线索二叉树的原理一样</p>
<img src="F:\Typora\img\image-20240303170029333.png" alt="image-20240303170029333" style="zoom:67%;" />

<p>代码实现，即一边遍历一边初始化</p>
<p>对于存在左右孩子为空结点来说，找遍历序列中的前驱和后继结点很简单</p>
<p><strong>那对于左右孩子非空的结点的来说，该如何找到其在遍历序列中的前驱和后继结点呢？</strong></p>
<p> 假设一个结点p，存在左右孩子结点，如何找到其中序遍历的后继结点呢？</p>
<p>中序遍历的顺序是左根右，因此后继结点在右孩子结点这棵树上</p>
<p>对以右孩子结点为根的这棵树再次进行中序遍历，第一个访问的结点即为p的后继结点</p>
<p>前驱结点同理，对以左孩子结点为根的这棵树再次进行中序遍历，最后一个访问的结点即为p的前驱结点</p>
<p>但二叉树的先序遍历找不到先序前驱，后序遍历找不到后序后继</p>
<p>如果是<strong>三叉结点</strong>（即保留指向父结点的子针），则可以找到</p>
<img src="F:\Typora\img\image-20240304091546705.png" alt="image-20240304091546705" style="zoom:67%;" />

<p>后序找后继也是同理</p>
<img src="F:\Typora\img\image-20240304091906267.png" alt="image-20240304091906267" style="zoom:67%;" />



















<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>分为内部排序（在内存中进行排序）和外部排序（数据量过大，需要借助外部存储进行排序）</p>
<h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>直接插入排序</p>
<p>希尔排序</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>简单选择排序</p>
<p>堆排序</p>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><p>冒泡排序</p>
<p>快速排序</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>算法必须具有有穷性，确定性，可行性</p>
<p>时间复杂度</p>
<p>空间复杂度</p>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><p>稀疏数组，三元组&lt;行，列，值&gt;</p>
<p>当一个数组中大部分元素为同一个值时，可用稀疏数组来保存该数组</p>
<p>二维数组转稀疏数组：遍历原始数组得到有效数据个数sum，根据sum值创建稀疏数组int[sum]+1，将二维数组的有效数据存入稀疏数组。</p>
<p>稀疏数组转二维数组：先读取稀疏数组第一行的数据，根据这些数据创建原始数组，然后依次读取稀疏数组剩下的值，并赋值给对应的位置。</p>
<p>或者采用链式存储——十字链表发法</p>
<img src="F:\Typora\img\image-20240218235644249.png" alt="image-20240218235644249" style="zoom:67%;" />



<p>对称矩阵</p>
<p>按行优先原则存储</p>
<p>创建一个长度为n*（n+1）&#x2F; 2 的数组来保存各个数据</p>
<p>实现一个映射函数，可以通过矩阵下标找到一维数组下标</p>
<p>Aij 是第 i*(i-1)&#x2F;2+j个元素</p>
<p>B[k] ， k&#x3D;i*(i-1)&#x2F;2+j -1</p>
<p>注意，以上是下三角区</p>
<p>若是采用上三角区，Aij可看为Aji</p>
<p>即从列的角度运用等差数列求和的方法，这样仍可以使用公式</p>
<p>三角矩阵</p>
<p>大致与对称矩阵类似，只是在最后一个位置存放常量的值</p>
<img src="F:\Typora\img\image-20240218234740884.png" alt="image-20240218234740884" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240218234723319.png" alt="image-20240218234723319" style="zoom:67%;" />









<h1 id="蓝桥杯算法"><a href="#蓝桥杯算法" class="headerlink" title="蓝桥杯算法"></a>蓝桥杯算法</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><img src="F:\Typora\img\image-20240304155311762.png" alt="image-20240304155311762" style="zoom:67%;" /><img src="F:\Typora\img\image-20240304155523318.png" alt="image-20240304155523318" style="zoom:67%;" /></p>
<p>1&lt;&lt;35与1&lt;&lt;3相同是因为，int只有32位，35-32&#x3D;3</p>
<h4 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h4><p>x&amp;1，如果为1则是奇数，如果为0则是偶数，因为奇数的最后一个位一定是1，因此&amp;后还是1</p>
<h4 id="判断某位是1还是0，"><a href="#判断某位是1还是0，" class="headerlink" title="判断某位是1还是0，"></a>判断某位是1还是0，</h4><p>仍然是利用与运算</p>
<p>先将1左移到与之相应的位置，此时除了该位是1，其他位置全是0，因此就可以进行与运算，得到结果，并将该结果重新右移到第一个位，然后再次进行奇偶判断</p>
<h4 id="交换两个整数变量的值，"><a href="#交换两个整数变量的值，" class="headerlink" title="交换两个整数变量的值，"></a>交换两个整数变量的值，</h4><p>即做三次异或运算</p>
<p>如交换a和b，a &#x3D; a ^ b;        b &#x3D; a ^ b;        a &#x3D; a ^ b;</p>
<p>此时a，b的值就进行了交换</p>
<p>异或运算的以下性质：</p>
<ol>
<li>结合律：a ^ (b ^ c) &#x3D; (a ^ b) ^ c</li>
<li>交换律：a ^ b &#x3D; b ^ a</li>
<li>自反性：a ^ a &#x3D; 0</li>
<li>零元素：a ^ 0 &#x3D; a</li>
</ol>
<h4 id="判断整数的绝对值"><a href="#判断整数的绝对值" class="headerlink" title="判断整数的绝对值"></a>判断整数的绝对值</h4><ol>
<li>获取符号位：将num右移31位（对于int类型，即取num的最高位作为符号位），得到符号位sign。如果num为正数，则sign为0；如果num为负数，则sign为-1。</li>
<li>计算绝对值：将num与sign进行异或操作（num ^ sign）。这一步的目的是，如果num为正数，异或操作不会改变num的值；如果num为负数，异或操作会取反num的所有位，但保留符号位为0。</li>
<li>根据符号位调整绝对值：将异或操作的结果再减去sign（即num ^ sign - sign）。如果num为正数，减去0不影响结果；如果num为负数，减去-1相当于加上1，得到num的绝对值。</li>
</ol>
<p> int num &#x3D; -10;       </p>
<p> int sign &#x3D; num &gt;&gt; 31;        </p>
<p>int absValue &#x3D; (num ^ sign) - sign;此时已经求出绝对值</p>
<p>下面以num &#x3D; -10为例演示计算过程：</p>
<ol>
<li>num &#x3D; -10 的二进制表示为：1111 1111 1111 1111 1111 1111 1111 0110</li>
<li>符号位 sign &#x3D; num &gt;&gt; 31 &#x3D; 1111 1111 1111 1111 1111 1111 1111 1111 &#x3D; -1</li>
<li>异或操作：num ^ sign &#x3D; 1111 1111 1111 1111 1111 1111 1111 0110 ^ 1111 1111 1111 1111 1111 1111 1111 1111 &#x3D; 0000 0000 0000 0000 0000 0000 0000 1001</li>
<li>绝对值调整：(num ^ sign) - sign &#x3D; 0000 0000 0000 0000 0000 0000 0000 1001 - (-1) &#x3D; 0000 0000 0000 0000 0000 0000 0000 1010 &#x3D; 10</li>
</ol>
<p>因此，对于输入的num &#x3D; -10，经过以上计算过程，我们得到其绝对值为10。</p>
<h3 id="题1：找唯一重复数"><a href="#题1：找唯一重复数" class="headerlink" title="题1：找唯一重复数"></a>题1：找唯一重复数</h3><p>异或的妙用：消除重复</p>
<p><img src="F:\Typora\img\image-20240304162011098.png" alt="image-20240304162011098"></p>
<p>利用异或的性质a ^ a &#x3D; 0，a ^ 0 &#x3D; a</p>
<p>将这1001个数都进行异或一次，我们会发现这两个重复的数就被消除了</p>
<p>那如果我们将这1001个数与不重复的1-1000这1000个数进行异或呢</p>
<p>不重复的树因为与另一边的数异或消除，而重复的数加上另一边就有3个数，正好保存下来了</p>
<p>如果不知道是哪些数就没法异或了，只能通过辅助存储空间，这里我想到list的contain方法，map以及哈希</p>
<p>还有个简单的求法，即求和，S2是1001个数的和，S1是1000个数的和，S2-S1即为答案</p>
<h3 id="题2：找出落单的数"><a href="#题2：找出落单的数" class="headerlink" title="题2：找出落单的数"></a>题2：找出落单的数</h3><img src="F:\Typora\img\image-20240304163408629.png" alt="image-20240304163408629" style="zoom:67%;" />

<p>直接异或这个数组，结果即是答案</p>
<h3 id="题3：二进制中1的个数"><a href="#题3：二进制中1的个数" class="headerlink" title="题3：二进制中1的个数"></a>题3：二进制中1的个数</h3><img src="F:\Typora\img\image-20240304191919387.png" alt="image-20240304191919387" style="zoom:67%;" />

<p>一个int有32位，结合之前判断某位是1还是0的方法，for循环32次，这样就可以判断每个位上是0还是1</p>
<p>也可以不左移1</p>
<p>而是选择右移这个数</p>
<p>还有一种方法，利用与运算来计算</p>
<p>如8的二进制是1000,8-1&#x3D;7的二进制是0111</p>
<p>1000和0111，这两个数进行与运算的话，结果0</p>
<p>（x-1)&amp;x，通过这种方法，我们可以消掉一个二进制的最后一个1</p>
<p>如8&amp;7&#x3D;0，</p>
<p>x&#x3D;9&#x3D;1010，9-1&#x3D;8&#x3D;1000,x&#x3D;9&amp;8&#x3D;1000，然后再8&amp;7&#x3D;0</p>
<p>直到最后结果为0，调用几次就有几个1</p>
<p>找最后一位1</p>
<p>则是x&amp;(-x)</p>
<h3 id="题4：整数是否为2的整数次方"><a href="#题4：整数是否为2的整数次方" class="headerlink" title="题4：整数是否为2的整数次方"></a>题4：整数是否为2的整数次方</h3><img src="F:\Typora\img\image-20240304193604352.png" alt="image-20240304193604352" style="zoom:67%;" />

<p>2的整数次方的特点为，二进制中只有一个1</p>
<p>因此与上一题的思路一致，只能调用一次上一题的方法（x-1)&amp;x</p>
<h3 id="题5：整数二进制奇偶位互换"><a href="#题5：整数二进制奇偶位互换" class="headerlink" title="题5：整数二进制奇偶位互换"></a>题5：整数二进制奇偶位互换</h3><p>int有32位，太长不好展示</p>
<p>以一个8位数为例</p>
<p>如果用0101 0101来进行与运算，则是保留奇数位的数字，假设结果为c</p>
<p>如果用1010 1010来进行与运算，则是保留偶数位是数字，假设结果为d</p>
<p>如果用c &amp; d，那么结果就是原来的二进制数</p>
<p>然后将c左移一位，将d右移一位，然后再次进行<strong>异或</strong>运行，则实现奇偶位互换</p>
<h3 id="题6：0-1间浮点实数的二进制"><a href="#题6：0-1间浮点实数的二进制" class="headerlink" title="题6：0~1间浮点实数的二进制"></a>题6：0~1间浮点实数的二进制</h3><img src="F:\Typora\img\image-20240304195845632.png" alt="image-20240304195845632" style="zoom:67%;" />

<p>给一种浮点数二进制的定义</p>
<p>与十进制转二进制类似，十进制转二进制是对2除法然后取余</p>
<p>而对于浮点数来说，则是逆运算</p>
<p>比如0.625，先乘2为1.25，发现小数点前有个1（该数大于等于1），则左边第一个位为1</p>
<p>然后去掉小数点前的1，为0.25，再次乘2为0.5，小数点前没有1，则接下来的第二位为0</p>
<p>因为小于1，所以不需要减1，再次乘2为1.0，小数点前有1，则第三位位1</p>
<p>然后再次减1为0，结束</p>
<p>因此结果为0.101</p>
<h3 id="题7：出现k次与出现1次的数"><a href="#题7：出现k次与出现1次的数" class="headerlink" title="题7：出现k次与出现1次的数"></a>题7：出现k次与出现1次的数</h3><img src="F:\Typora\img\image-20240304204952164.png" alt="image-20240304204952164" style="zoom:67%;" />

<p>2个相同的二进制数做不进位加法，结果为0，如3的二进制数为011,011+011&#x3D;110，这是进位的，如果不进位则是000</p>
<p>10个相同的十进制数做不进位加法，结果同样为0，如10个3相加为30，个位为0</p>
<p>k个相同的k进制数做不进位加法，结果为0</p>
<p>因此出现了k次，我们就将这些数都转化为k进制数，然后进行不进位加法</p>
<p>最后结果就是只出现一次的数，然后将其还原为十进制</p>
<p> 有种方法可以帮助我们转为任意进制</p>
<p>Integer.toString(i,radix)，i是数，radix是进制</p>
<p>转化完之后记得翻转，因为我们是从第一位开始计算的</p>
<p>不进位加法的实现对每一列进行取余，十进制就逢10减10，二进制就逢2减2</p>
<p>这样子就得到每一位上的数值</p>
<p>2,2,2,3,3,3,7,7,7,8</p>
<p>出现次数为3，则转位三进制</p>
<p>2&#x3D;2,3&#x3D;10,7&#x3D;21,8&#x3D;22</p>
<p>然后对第一位进行取余，2+2+2+0+0+0+1+1+1+2&#x3D;11,11%3&#x3D;2，则第一位的数是2</p>
<p>对第二位进行取余，2没有第二位，故不参与，1+1+1+2+2+2+2&#x3D;11,11%3&#x3D;2，第二位的数是2</p>
<p>没有第三位了，结束</p>
<p>三进制22对应的十进制是8</p>
<p>可以用map的哈希表，key-value来运算，就很简单了</p>
<h3 id="课外作业"><a href="#课外作业" class="headerlink" title="课外作业"></a>课外作业</h3><p>用位运算实现求和，求差，乘除</p>
<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><img src="F:\Typora\img\image-20240305134458012.png" alt="image-20240305134458012" style="zoom:67%;" />

<p>找重复，找变化，找边界</p>
<p>我做一部分，剩下的让别人做，直到最后有人恰好做完</p>
<p>递归就是将一个问题中不断重复的行为提取出来，将父问题转为子问题</p>
<p>变化的量通常为参数</p>
<p>一定要找到出口</p>
<p>尝试切一刀，划分为规模更小的问题，但记得保持条件的一致</p>
<p>如果切不了，可能是数学问题，从数学性质的角度出发</p>
<p>递归的本质是子问题的划分，求等价于什么子问题</p>
<h3 id="基础练习例题："><a href="#基础练习例题：" class="headerlink" title="基础练习例题："></a>基础练习例题：</h3><h4 id="求n的阶乘"><a href="#求n的阶乘" class="headerlink" title="求n的阶乘"></a>求n的阶乘</h4><p>找重复：n的阶乘是n*(n-1)的阶乘，求n-1的阶乘是原问题的重复，是规模更小的子问题，是返回值</p>
<p>找变化：变化的量应该作为参数，这题中n在不断变化</p>
<p>找边界：出口，当n&#x3D;1时，返回1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * f1(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印i-j"><a href="#打印i-j" class="headerlink" title="打印i-j"></a>打印i-j</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    System.out,println(i);</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f2(i+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == arr.length -<span class="number">1</span>) <span class="keyword">return</span> arr[k];</span><br><span class="line">    <span class="keyword">return</span> f3(arr,k+<span class="number">1</span>) + arr[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">f4</span><span class="params">(String src,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == src.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + src.charAt(k);</span><br><span class="line">    <span class="keyword">return</span> f4(src,k+<span class="number">1</span>) + src.charAt(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;对于不能一眼没有递归思路的数学题，需要其递推公式或者等价转换</p>
<h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f5</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f5(n-<span class="number">1</span>) + f5(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f6</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m % n == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> f6(n,m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序改为递归"><a href="#插入排序改为递归" class="headerlink" title="插入排序改为递归"></a>插入排序改为递归</h4><p>对数组排序  -&gt; 对数组部分排序  -&gt;  对数组的0-倒数第二个元素部分排序，然后将最后一个元素插入到有序部分</p>
<p>一直规模缩小化，则是对数组的第一个和第二个元素排序，然后将第三个元素插入……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对前k - 1个元素排序</span></span><br><span class="line">    insertSort(arr,k-<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[k];</span><br><span class="line">    <span class="comment">//然后将第k个元素插入到对应的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; arr[index] &amp;&amp; index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//如果这个元素小于当前元素，则当前元素后移一位</span></span><br><span class="line">        arr[index + <span class="number">1</span>] = arr[index];</span><br><span class="line">        index --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个元素大于当前元素，插入到当前元素的下一个</span></span><br><span class="line">    arr[index + <span class="number">1</span>] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p>先用文字描述问题，尝试切一刀</p>
<p>将1-n从A移动到B，C作为辅助</p>
<p>然后尝试一下“切”一刀，看看能不能分为两部分，其中一部分是变量，另一部分是小规模的问题</p>
<p>尝试在1处进行切，此时将分为1和2-n，1放在C上，问题是2-n怎么到B上</p>
<p>审视一下，把1-n，移动到B与2-n移动到B，是不是规模更小的同等问题，条件是不是一样</p>
<p>对于1-n，B，C都是空的</p>
<p>对于2-n，只有B是空的，故条件不一致，不是规模更小的等价问题</p>
<p>为了实现本题目的，多次观察得出</p>
<p><strong>必须先实现将最大的盘子移到B上，将1-n-1移动到C上</strong></p>
<p>因此尝试在最后两个盘子间切一刀，分为n和1-n-1这两部分</p>
<p>对于1-n-1到C，有B，C是空的这两个条件，与原来的条件一致，只是B，C的角色发生变化，但实际上是一样的，规模变小了</p>
<p><strong>然后再实现1-n-1再次到B的过程</strong></p>
<p>此时A为空，B上只有n，但n不需要移动，可视为空，故有两个柱子可以使用</p>
<img src="F:\Typora\img\image-20240305215057898.png" alt="image-20240305215057898" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240305215259952.png" alt="image-20240305215259952" style="zoom:67%;" />

<h4 id="二分查找递归解法"><a href="#二分查找递归解法" class="headerlink" title="二分查找递归解法"></a>二分查找递归解法</h4><p>对于二分查找来说</p>
<p>每次递归只有起点和终点其中一个数值发生了变化，其他条件一致，可以使用递归</p>
<p>等价于左边找，中间比，右边找</p>
<img src="F:\Typora\img\image-20240305215641781.png" alt="image-20240305215641781" style="zoom:67%;" />

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>没学过，不是很懂，还有选择排序也不是很懂</p>
<img src="F:\Typora\img\image-20240305221056033.png" alt="image-20240305221056033" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240305221657951.png" alt="image-20240305221657951" style="zoom:67%;" />

<p>增量序列用于分组，4就是分4组，2就是分2组</p>
<p>空间想象，第一次时，中间位置的下标增量序列</p>
<p>每一个的插入排序，都是在自己组里的插入排序</p>
<p>将一个大的组，分为小的组</p>
<p>有点牛，多个组插入排序处不太理解</p>
<img src="F:\Typora\img\image-20240305223332514.png" alt="image-20240305223332514" style="zoom:67%;" />



<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>利用二分查找法可以快速在有序数组中找到特定数字或字符串，可应用在不同的环境，不止插入数字</p>
<p>可应用于将一个有序数组前部分一点到最后面，找出移动的下标以及有序字符串中找到特定字符串</p>
<p>双指针可应用于部分有序的数组找最长的子数组</p>
<p> 如何有效写出一个求a的n次方算法</p>
<p>以倍数进行尝试求，如a^2,a^4,a^16</p>
<p>以平方的速度进行求</p>
<img src="F:\Typora\img\image-20240308161438660.png" alt="image-20240308161438660" style="zoom:67%;" />



<h2 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h2><p>划分区域</p>
<img src="F:\Typora\img\image-20240308162117034.png" alt="image-20240308162117034" style="zoom:67%;" />

 <img src="F:\Typora\img\image-20240308162435207.png" alt="image-20240308162435207" style="zoom:67%;" />

<p>双指针双向扫描，第一个元素为主元，左指针进行左移，找到大于主元的就和右指针交换，右指针前移一次，左指针重新判断</p>
<img src="F:\Typora\img\image-20240308201246944.png" alt="image-20240308201246944" style="zoom:67%;" />

<p>双指针双向扫描，第一个元素为主元，另外两个一左一右，都进行移动比较</p>
<img src="F:\Typora\img\image-20240308225835358.png" alt="image-20240308225835358" style="zoom:67%;" />

<p> 对于有重复值的，可采用三指针，划分为三个区间，第一个区间为小于，第二个为等于，第三个为大于</p>
<p>三点中值法：在最左边，最右边以及中间取中间值作为主元</p>
<p>然后划分为左边为小于该主元，右边为大于该主元</p>
<p>绝对中值法：分组去中间值，然后再分组取中间值，直到取得</p>
<p><img src="F:\Typora\img\image-20240309132628509.png" alt="image-20240309132628509"></p>
<p>有时候求数组中的某个数字可以创建一个辅助空间</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>有点难，不太会，大致思想是整棵树的父结点都是大于子节点，或者小于子节点</p>
<p>从n&#x2F;2个结点开始，从倒数第二层的结点开始，每一次交换就需要重新往下判断交换一次</p>
<img src="F:\Typora\img\image-20240309212823101.png" alt="image-20240309212823101" style="zoom:67%;" />



<h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><p><strong>利用局部最优解来推导全局最优解</strong></p>
<p>不断选取当前的最优策略，最终找到最优解</p>
<p>难点：当前最优未必整体最优</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>避免重复节点的计算，空间换时间，利用某个存储结构来保存后面的结果</p>
<p>如果发现遍历中存在大量的重复计算，就可以使用哈希表将数据缓存下来，之后遍历到相同的节点就直接查表</p>
<p>观察公式的求解顺序</p>
<img src="F:\Typora\img\image-20240318144410751.png" alt="image-20240318144410751" style="zoom:67%;" />

<p>从后往前推</p>
<img src="F:\Typora\img\image-20240318144717542.png" alt="image-20240318144717542" style="zoom:67%;" />

<p>最优子结构或者说子问题最优性</p>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>是一个声明式的http客户端，作用是实现http请求的发送</p>
<img src="F:\Typora\img\image-20240215160642441.png" alt="image-20240215160642441" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240215160655277.png" alt="image-20240215160655277" style="zoom:67%;" />

<p>feign的日志配置可以通过配置文件，也可以通过java代码实现</p>
<p>通过代码的话，需要在启动类中添加注解配置，并编写相关配置类</p>
<img src="F:\Typora\img\image-20240215205058856.png" alt="image-20240215205058856" style="zoom:67%;" />

<p>优化feign的性能</p>
<p>使用连接池代替默认的URLConnection</p>
<p>日志级别选用basic或者none</p>
<img src="F:\Typora\img\image-20240215171409996.png" alt="image-20240215171409996" style="zoom:67%;" />

<p>feign调用的是其他微服务的controller层里的方法，因此对应的请求路径及参数等须一致</p>
<p>对此，有以下方法</p>
<img src="F:\Typora\img\image-20240215204231556.png" alt="image-20240215204231556" style="zoom:67%;" />

<p>但以上这个方法不推荐，耦合度过高</p>
<img src="F:\Typora\img\image-20240215204444774.png" alt="image-20240215204444774" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240215204606411.png" alt="image-20240215204606411" style="zoom:67%;" />

<p>通过这种方式启动时，没法自动注入client的相关对象，扫描不到其对应的包</p>
<img src="F:\Typora\img\image-20240215205446301.png" alt="image-20240215205446301" style="zoom:67%;" />









<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>su : 切换root用户</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>docker –help ： 查看所有命令</p>
<p>docker xxx –help ： 查看xxx命令的使用方法</p>
<p>docker imgaes ： 查看镜像</p>
<p>docker build ： 本地构建镜像</p>
<p>docker rmi xxx:xx ： 删除镜像</p>
<p>docker pull xxx ： 拉取镜像</p>
<p>docker push ： 推送镜像</p>
<p>docker save -o xxx.tar xxx:xx ： 压缩镜像</p>
<p>docker load -i xxx.tar ： 加载镜像压缩</p>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>容器有自己的环境，无法直接ping到容器自己的ip，容器是相互隔离的</p>
<p>docker run ： 创建并运行容器</p>
<p>​		eg：docker run –name containerName -p 80:80 -d nginx</p>
<p>​		–name：容器名字		-p：宿主机端口与容器端口映射，左边为宿主机端口，右边为容器端口		-d：后台运行</p>
<p>​		-v html:&#x2F;root&#x2F;html ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中，具体目录可以到dockerhub官网查，也可以不通过数据		卷，自己指定文件和目录来挂载</p>
<p>​		-v volume名称：容器内目录</p>
<p>​		-v 宿主机文件：容器内文件</p>
<p>​		-v 宿主机名称：容器内目录</p>
<p>​		-e 设置环境变量</p>
<p>docker pause xxx ： 暂停容器</p>
<p>docker unpause xxx ： 恢复容器</p>
<p>docker stop xxx ： 停止容器</p>
<p>docker start xxx ： 启动容器</p>
<p>docker exec ： 进入容器内部执行命令，不推荐</p>
<p>​		eg：docker exec -it mn bash</p>
<p>​		-it：标准输入输出终端，允许和容器交互		mn：容器名字		bash：进入容器后执行的命令，bash是linux终端交互命令	</p>
<p>docker logs  xxx： 查看容器运行日志</p>
<p>​		xxx：容器名字		-f：持续跟踪日志信息，ctrl+c即可停止</p>
<p>docker ps ： 查看所有运行的容器及状态</p>
<p>​		-a：查看所有容器，包括停止的</p>
<p>docker rm xxx ： 彻底删除指定容器</p>
<p>​		-f：强制删除运行中的容器</p>
<h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><p>数据卷是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁</p>
<p>docker volume [COMMAND]</p>
<p>create：创建一个数据卷</p>
<p>inspect：显示一个或多个数据卷详细信息</p>
<p>ls：列出所有数据卷</p>
<p>prune：删除未使用的数据卷</p>
<p>rm：删除一个或多个指定的数据卷</p>
<p>如何挂载数据卷呢</p>
<p>在使用docker run命令的时候，使用 -v 数据卷 ： 容器内目录进行数据卷的挂载</p>
<p>如果容器已经创建了，是没有办法再次进行挂载的，一定要在创建容器时进行挂载</p>
<p>如果挂载时数据卷不存在，会自动进行数据卷的创建，因此不需要调用create创建数据卷</p>
<p>有些容器，尽管我们没有挂载数据卷，但容器创建时，有些会自动挂载一个匿名数据卷</p>
<p>当你删除这个容器时，其对应的数据卷并不会被删除，如果你重新安装，会重新挂载一个新的数据卷，这样子你只是升级了版本</p>
<p>而原来的数据在原来的数据卷里，数据没有保存到新的数据卷里</p>
<p>建议自己创建一个本地目录来挂载数据卷</p>
<p>只要挂载了同一个目录，数据就不会丢失</p>
<h3 id="如何自定义镜像"><a href="#如何自定义镜像" class="headerlink" title="如何自定义镜像"></a>如何自定义镜像</h3><p>如何将自己的java应用打包成镜像上传到docker</p>
<p>准备linux服务器运行环境</p>
<p>安装jre并配置环境变量</p>
<p>拷贝jar包</p>
<p>编写运行脚本</p>
<p>可利用dockerfile来帮助我们简化</p>
<p>docker build -t 命令来构建镜像</p>
<p>网络</p>
<p>每次启动docker中的容器，都会分配一个虚拟网桥其下的ip地址</p>
<p>启动顺序不同，则同一个容器在不同的启动顺序下，ip地址是会发生变化的</p>
<p>容器内如何互相访问ip地址呢</p>
<p>我们可以给每一个容器创建一个网络</p>
<p>加入自定义网络的容器才可以通过容器名互相访问</p>
<p>即同一个网络里的容器才可以通过容器名互相访问</p>
<h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p>一键部署多个docker容器和镜像，一键部署项目</p>
<p>也可以一键部署集群</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis企业实战"><a href="#Redis企业实战" class="headerlink" title="Redis企业实战"></a>Redis企业实战</h2><h3 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h3><h4 id="1、基于session实现登录"><a href="#1、基于session实现登录" class="headerlink" title="1、基于session实现登录"></a>1、基于session实现登录</h4><p>实际上用token和jwt来验证登录， 了解一下即可</p>
<img src="F:\Typora\img\image-20240319143010909.png" alt="image-20240319143010909" style="zoom:67%;" />

<p>题外话</p>
<p>Cookie、Session、Token究竟区别在哪？如何进行身份认证，保持用户登录状态？</p>
<p>首先，http是无状态的，这次访问完，关闭服务器，再次访问，服务器是没有意识到又是你来访问</p>
<p>Cookie可以实现每次http请求都自动携带数据给服务器，保存在浏览器端</p>
<p>session，保存在服务端里，服务器接收到浏览器请求后，返回一个sessionid和有效时间给浏览器，浏览器将其保存到cookie中</p>
<p>相当于把cookie里的用户名和密码用数据库中的sessionID进行对应</p>
<p>cookie最早，既是验证机制，也是存储方式，验证信息存在本地，且可以由本地生成。<br>session，服务端生成，本地只存sessionid，sessionid由服务端生成，且验证信息存在服务端。<br>token，服务端生成，存在本地，相比与session只存一个id，本地存的信息更多，如header和payload，尤其是payload，可以确认用户信息。这样，服务端只要保证唯一密钥不丢失。每次都是临时通过header和payload配合密钥去生成signature验证用户身份的。<br>其实最重要的也就是signature，但是由于密钥只在服务端，如果本地token不泄露，其他人无法根据header和payload生成正确的signature，也无法通过修改payload去假冒其他用户或者篡改该用户的其他信息。</p>
<h4 id="redis在session中的应用"><a href="#redis在session中的应用" class="headerlink" title="redis在session中的应用"></a>redis在session中的应用</h4><p>redis的作用之一：可作为一个外部的共享的内存存储空间</p>
<p>但在分布式中，建议还是jwt校验登录状态</p>
<p>多台tomcat并不共享session存储空间，当请求切换到不同tomcat服务时，导致数据丢失</p>
<p>session的替代方案应该满足：数据共享，内存存储，key、value结构</p>
<p>可以将手机号作为key，验证码作为value存到redis，校验手机验证码就是查询redis中的value，判断是否一致</p>
<p>这个简单，代码就不写了</p>
<p>登录时则将token作为key，用户信息作为value存到redis中，也可以使用hash结构，不一定是string，每次校验登录状态就是从获取token</p>
<img src="F:\Typora\img\image-20240319171935630.png" alt="image-20240319171935630" style="zoom:67%;" />

<p>这里将map保存到redis时会出错，因为StringRedisTemplate的两个泛型都是string类型</p>
<p>id是long类型，两个类型不一样会报错</p>
<p>但转换方法允许你自定义hashmap</p>
<img src="F:\Typora\img\image-20240319184108097.png" alt="image-20240319184108097" style="zoom:67%;" />

<p>此处只需要想一想如何将id的long类型，转换为string类型，不是一定要用这个方法，有人说直接用RedisTemplate</p>
<p>而不是StringRedisTemplate</p>
<p>token记得在第一次登录时返回给客户端，这样子前端才可以在请求头中携带token  </p>
<img src="F:\Typora\img\image-20240319183110553.png" alt="image-20240319183110553" style="zoom:67%;" />

<p>因为在上面我们是采用了hashmap集合来保存user对象，因此这里我们需要将其还原成user对象，都是hutool包里的对象的方法</p>
<img src="F:\Typora\img\image-20240319183317831.png" alt="image-20240319183317831" style="zoom:67%;" />

<p>然后判断用户是否存在，存在就保存到threadlocal线程中</p>
<p>session是只要不操作了，30分钟后过期，那么redis该如何实现呢</p>
<p>在拦截器中实现，在拦截器中更新token的有效期</p>
<img src="F:\Typora\img\image-20240319183500991.png" alt="image-20240319183500991" style="zoom:67%;" />

<p>注意，拦截器类不是string容器的组件，其对象是需要我们自己创建，spring容器不会自动创建</p>
<p>因此在这里<strong>没法使用</strong>@Autowire和@Resource注解注入StringRedisTemplate</p>
<p>但我们可以在配置类中注入，因为配置类是string容器的组件</p>
<img src="F:\Typora\img\image-20240319181944383.png" alt="image-20240319181944383" style="zoom:67%;" />

<p>这样子就可以注入StringRedisTemplate对象了</p>
<img src="F:\Typora\img\image-20240319182224178.png" alt="image-20240319182224178" style="zoom:67%;" />

<p>此时只有需要访问拦截器检验登录状态的页面，token才会刷新</p>
<p>当访问首页这种不需要登录校验的时，拦截器不会刷新token </p>
<p>因此需要优化一下，在第一个路径中放行一切</p>
<img src="F:\Typora\img\image-20240319195539306.png" alt="image-20240319195539306" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240319200251070.png" alt="image-20240319200251070" style="zoom:67%;" />

<p>可通过order命令指定顺序</p>
<h4 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h4><p>可以给数据添加redis缓存，加快数据的读写性能</p>
<img src="F:\Typora\img\image-20240319210557571.png" alt="image-20240319210557571" style="zoom:67%;" />



<h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>如果数据库更新而redis未更新，则读取到的是旧数据，是不允许的</p>
<img src="F:\Typora\img\image-20240319212204745.png" alt="image-20240319212204745" style="zoom:67%;" />

<p>建议一直编写过期时间</p>
<p>在缓存更新时可以采用删除缓存，然后在下次查询时重新缓存</p>
<p>要保证更新数据库和删除缓存同时成功或失败</p>
<img src="F:\Typora\img\image-20240319213139617.png" alt="image-20240319213139617" style="zoom:67%;" />

<p>先操作数据库还是缓存呢？</p>
<p>建议<strong>先更新数据库，再删除缓存</strong>，</p>
<p>因为操作数据库时间相对较长，而操作内存中的缓存时间相对较短</p>
<p>但还是有可能发生线程安全问题，最好还是加锁来保证原子性</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>即redis和数据库都没有该对象时，永远不会在redis中进行缓存</p>
<p>每次访问都会访问到数据库中</p>
<p>如何解决呢，即返回一个<strong>空字符串对象</strong>到redis中，但这样会产生一个缺陷</p>
<p>即刚刚好下次正好创建了这个对象并保存到了数据库中，查询时因为缓存已经有了空字符串对象，导致数据不一致，只有等过期时间到达，再次查询才能一致。  可以在创建时<strong>自动更新缓存</strong>来解决</p>
<p>有个更好的方法，即采用<strong>布隆过滤器</strong></p>
<p>每次查询时先访问布隆过滤器，缓存或者数据库存在才给你访问，不存在则拒绝</p>
<p>布隆过滤器并没有保存所有的数据，而是保存二进制数据，根据某种哈希算法判断</p>
<p>如果布隆过滤器拒绝则一定不存在，但放行不一定存在，因此还是有一定的缓存穿透风险</p>
<img src="F:\Typora\img\image-20240319220324997.png" alt="image-20240319220324997" style="zoom:67%;" />

<p>还可以增强id的复杂度，避免被猜测id规律导致大量访问，以及做好各种校验来减少请求量</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>即同一时间段内大量的缓存key同时失效，或者redis服务挂了，导致大量的请求到达数据库，带来巨大压力</p>
<img src="F:\Typora\img\image-20240319222033201.png" alt="image-20240319222033201" style="zoom:67%;" />



<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，大量的请求访问会在瞬间给数据库带来巨大的冲击</p>
<p>即热点数据的key失效了</p>
<img src="F:\Typora\img\image-20240319222703284.png" alt="image-20240319222703284" style="zoom:67%;" />

<p>设置互斥锁之后，后面的会互相等待，导致性能下降，可用性下降</p>
<p>使用逻辑过期，则会导致数据可能不一致，一致性下降</p>
<img src="F:\Typora\img\image-20240319223525334.png" alt="image-20240319223525334" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240319223641453.png" alt="image-20240319223641453" style="zoom:67%;" />



<h4 id="利用互斥锁解决缓存击穿"><a href="#利用互斥锁解决缓存击穿" class="headerlink" title="利用互斥锁解决缓存击穿"></a>利用互斥锁解决缓存击穿</h4><p>利用setnx命令</p>
<p>但还是不如redission</p>
<p>此处是查询店铺，可以给每一个店铺一个互斥锁的key，即以id为基础</p>
<img src="F:\Typora\img\image-20240320210345452.png" alt="image-20240320210345452" style="zoom:67%;" />

<p>加锁代码</p>
<img src="F:\Typora\img\image-20240320210531258.png" alt="image-20240320210531258" style="zoom:67%;" />

<p>添加过期时间，防止挂了之后无人释放锁</p>
<p>使用工具类是为了避免<strong>自动拆箱</strong>时返回null值</p>
<p>释放锁代码</p>
<img src="F:\Typora\img\image-20240320210705071.png" alt="image-20240320210705071" style="zoom:67%;" />



<h4 id="利用逻辑过期解决缓存击穿"><a href="#利用逻辑过期解决缓存击穿" class="headerlink" title="利用逻辑过期解决缓存击穿"></a>利用逻辑过期解决缓存击穿</h4><p>不是由redis判断是否过期，而是程序员自己判断是否过期</p>
<p><strong>提前</strong>将热点商品，商家保存到redis中</p>
<p>利用一个新的类来保存逻辑过期时间</p>
<p>这个类中含有逻辑过期时间以及对应的Object数据对象</p>
<img src="F:\Typora\img\image-20240320212903150.png" alt="image-20240320212903150" style="zoom:67%;" />

<p>注重，获取锁成功应该再次检测redis缓存是否过期（因为你获取成功，可能是别人刚刚释放的锁，别人已经做好了更新），做双重检测，如果未过期则无需重建缓存，可能你获取的时候刚好是别人释放的时候</p>
<p>开启独立线程，最好是让线程池来开启一个新线程</p>
<p>总结：只要Redis中获取到数据，就返回这个数据用着。如果发现缓存过期，尝试去获取锁，获取到锁的线程只是通知重建线程去更新数据，而没有获取到锁的线程啥事不用管</p>
<h4 id="缓存工具类封装"><a href="#缓存工具类封装" class="headerlink" title="缓存工具类封装"></a>缓存工具类封装</h4><p>可以根据上面学的，将各种方法封装起来</p>
<img src="F:\Typora\img\image-20240320233737237.png" alt="image-20240320233737237" style="zoom:67%;" />

<p>方法一和二代码如下</p>
<img src="F:\Typora\img\image-20240320234609827.png" alt="image-20240320234609827" style="zoom:67%;" />

<p>方法三和四代码相对复杂，但根据流程来并不难</p>
<p>涉及到了函数式编程，刚开始学，还是多写代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yiminacg.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.yiminacg.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LZT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/10/31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置过期时间防止缓存雪崩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置逻辑过期防止缓存击穿</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogical</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对数据库中没有的对象返回null防止缓存穿透</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T,ID&gt; T <span class="title function_">queryWithIdPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;T&gt; type,</span></span><br><span class="line"><span class="params">                      Function&lt;ID,T&gt; db,Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">//根据key的前缀和id获取key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">//在redis中查询key是否存在</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">            <span class="comment">//存在,直接返回</span></span><br><span class="line">            <span class="comment">//将json数据反序列化</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json,type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否为null，上面这个判断为null返回false</span></span><br><span class="line">        <span class="keyword">if</span>(json == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//上一次查询数据库中没有这个数据，数据库已经返回null了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> db.apply(id);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果数据库不存在这个信息，将null返回给redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key,t,time,unit);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> &lt;T,ID&gt; T <span class="title function_">queryWithLogical</span><span class="params">(String keyPrefix, ID id, Class&lt;T&gt; type,</span></span><br><span class="line"><span class="params">                                     Function&lt;ID,T&gt; db,Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//防止缓存击穿</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">//在redis查询用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(json))&#123;</span><br><span class="line">            <span class="comment">//不存在,直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//redis中存在该用户,将json数据反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json,RedisData.class);</span><br><span class="line">        <span class="comment">//将redisData中的数据取出来，由于里面的是Object类型，所以先序列号然后反序列化</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject)redisData.getData(),type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="comment">//未过期</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已过期，进行缓存重建</span></span><br><span class="line">        <span class="comment">//先获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_USER_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">            <span class="comment">//获取成功,开启独立线程进行缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重建缓存，先查数据库，再写redis</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> db.apply(id);</span><br><span class="line">                    <span class="built_in">this</span>.setWithLogical(key,t1,time,unit);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(lockKey,<span class="string">&quot;1&quot;</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3、优惠券秒杀"><a href="#3、优惠券秒杀" class="headerlink" title="3、优惠券秒杀"></a>3、优惠券秒杀</h4><h5 id="全局id生成器"><a href="#全局id生成器" class="headerlink" title="全局id生成器"></a>全局id生成器</h5><p><strong>雪花算法</strong>也可以</p>
<p>了解即可</p>
<p>为什么不用数据库的自增id呢</p>
<p>因为id的规律太明显，并且受单表数据量的限制</p>
<p>全局id生成器是一种在<strong>分布式系统</strong>下用来生成<strong>全局唯一ID</strong>的工具</p>
<img src="F:\Typora\img\image-20240321182740864.png" alt="image-20240321182740864" style="zoom:67%;" />

<h5 id="秒杀下单"><a href="#秒杀下单" class="headerlink" title="秒杀下单"></a>秒杀下单</h5><p>此时只是秒杀的流程，尚未涉及锁</p>
<img src="F:\Typora\img\image-20240321201851562.png" alt="image-20240321201851562" style="zoom:67%;" />

<p>为了避免超卖的问题，我们需要设置锁</p>
<p>redis是单线程，可以在redis中查询和扣减，但要保证原子性</p>
<h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h5><p>还是推荐redission分布式锁</p>
<img src="F:\Typora\img\image-20240321203930689.png" alt="image-20240321203930689" style="zoom:67%;" />

<p>悲观锁相对简单，即每次都加锁</p>
<p>而乐观锁什么时候生效呢</p>
<p>有两种方法</p>
<img src="F:\Typora\img\image-20240321205046276.png" alt="image-20240321205046276" style="zoom:67%;" />

<p>另一种方法是在版本号法的基础上改进的</p>
<p>版本号每次都会修改，库存也是每次都会修改，为什么不能让库存当做版本号来使用呢？</p>
<p>CAS法就是这样的思想</p>
<img src="F:\Typora\img\image-20240321205305798.png" alt="image-20240321205305798" style="zoom:67%;" />

<p>使用乐观锁，可以避免超卖，但是不能避免在库存充足的情况下，查的时候刚好是别人买的时候，这样子就卖不出去了</p>
<p>失败率过高</p>
<p>修改为判断库存是否大于0，大于0就成功</p>
<img src="F:\Typora\img\image-20240321210437907.png" alt="image-20240321210437907" style="zoom:67%;" />

<h5 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h5><p><img src="F:\Typora\img\image-20240321210919154.png" alt="image-20240321210919154"></p>
<p>同样地，如果先开启事务，再释放锁，然后会出现问题，应该<strong>先加锁，再开启事务</strong>，但这样只能在单机使用</p>
<p>这里还涉及到了<strong>事务代理对象</strong>，不了解，还需要导对应的<strong>aspectjweave</strong>r包？？？</p>
<img src="F:\Typora\img\image-20240321214657506.png" alt="image-20240321214657506" style="zoom:67%;" />

<p>集群模式下如何设置锁</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>需要一个jvm外部的监视器</p>
<p>前两个锁的都是jvm内部的监视器</p>
<img src="F:\Typora\img\image-20240321221826950.png" alt="image-20240321221826950" style="zoom:67%;" />

<p>可在redis中查询，利用setnx判断是否用户id+商品id这个key是否存在，进行去重</p>
<img src="F:\Typora\img\image-20240322162423775.png" alt="image-20240322162423775" style="zoom:67%;" />

<h5 id="初级版本"><a href="#初级版本" class="headerlink" title="初级版本"></a>初级版本</h5><p>直接调用setIfAbsent方法，key是外部传入的以用户id为基础的，value是线程</p>
<img src="F:\Typora\img\image-20240322163705251.png" alt="image-20240322163705251" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240322164324769.png" alt="image-20240322164324769" style="zoom:67%;" />

<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果当线程1业务阻塞的时候，导致锁超时释放了</p>
<p>如果此时线程2也来获取锁，这时锁已经释放了，能够成功获取锁，开始执行业务</p>
<p>然后线程1业务不阻塞了，执行了自己的业务后把锁给释放了，此时释放的是线程2的锁</p>
<p>线程2不知道锁被释放了，仍继续执行自己的业务</p>
<p>如果线程3也来了，又会继续发生这样的事情</p>
<p>还是发生了线程安全的问题</p>
<p>因此我们释放锁的时候，应该判断<strong>锁标识是否一致</strong>，避免释放的是别人的锁</p>
<p>因此，上面的流程发生了变化</p>
<img src="F:\Typora\img\image-20240322170223878.png" alt="image-20240322170223878" style="zoom:67%;" />

<p>uuid在多台jvm下，可能出现相同的id，雪花算法</p>
<p>也可以采取uuid+线程id，放在value里，利用value判断锁标识是否一致</p>
<img src="F:\Typora\img\image-20240322170945257.png" alt="image-20240322170945257" style="zoom:67%;" />

<h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>如果这次不是业务阻塞了，而是jvm恰好在判断锁一致后阻塞了</p>
<p>然后另一个锁获取完后，又恢复了，于是又释放了其他人的锁</p>
<p>因此我们我们需保证判断锁标识和释放锁这两个操作是<strong>原子性</strong>的，要一起执行</p>
<p>使用lua脚本，lua是一种编程语言，应该可以让gpt帮我写</p>
<p>利用<strong>redis.call</strong>调用函数</p>
<p>我们可以在redis中调用<strong>EVAL</strong>命令，执行脚本</p>
<p> lua里，数组下标从1开始</p>
<img src="F:\Typora\img\image-20240322185041675.png" alt="image-20240322185041675" style="zoom:67%;" />



<p>编写好lua脚本文件unlock.lua</p>
<img src="F:\Typora\img\image-20240323112512851.png" alt="image-20240323112512851" style="zoom:67%;" />

<p>创建脚本对象并指定好脚本文件</p>
<img src="F:\Typora\img\image-20240323112844254.png" alt="image-20240323112844254" style="zoom:67%;" />

<p>然后调用脚本</p>
<img src="F:\Typora\img\image-20240323112951212.png" alt="image-20240323112951212" style="zoom:67%;" />

<p>第一个参数是脚本对象，第二个是key的集合，第三个是value的集合，也可以先创建集合再填写，不是一定要像图片这样</p>
<p>此时只是解决了被别人删除锁的问题，但服务宕机导致别人进入，这个问题比较难解决</p>
<img src="F:\Typora\img\image-20240323113504192.png" alt="image-20240323113504192" style="zoom:67%;" />





<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>基于setnx实现的分布式锁存在的问题</p>
<p>不可重入：即同一个线程无法多次获取同一把锁</p>
<p>不可重试：只尝试一次就返回false时，没有重试</p>
<p>超时释放问题</p>
<p>主从一致性问题</p>
<h5 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h5><img src="F:\Typora\img\image-20240323161646800.png" alt="image-20240323161646800" style="zoom:67%;" />

<p>config记得找redisson提供的，不要导错包了</p>
<p>密码看你自己的redis地址是否有设置密码</p>
<img src="F:\Typora\img\image-20240323161907882.png" alt="image-20240323161907882" style="zoom:67%;" />

<h5 id="可重入锁原理"><a href="#可重入锁原理" class="headerlink" title="可重入锁原理"></a>可重入锁原理</h5><p>利用hash结构来保存锁，线程id以及访问次数</p>
<p>第一次访问则创建，填写信息</p>
<p>然后自己这个线程每次访问，次数都加1</p>
<p>如果不是本线程来访问，则拒绝</p>
<p>退出的时候，次数-1</p>
<p>减到0了则释放锁</p>
<img src="F:\Typora\img\image-20240323184924106.png" alt="image-20240323184924106" style="zoom:67%;" />

<p>获取和释放锁，可以使用lua脚本确保一致性，redisson底层好像就是lua脚本？？？？？？？</p>
<img src="F:\Typora\img\image-20240323185048816.png" alt="image-20240323185048816" style="zoom:67%;" />	

<img src="F:\Typora\img\image-20240323185255454.png" alt="image-20240323185255454" style="zoom:67%;" />



<h5 id="锁重试和watchdog机制"><a href="#锁重试和watchdog机制" class="headerlink" title="锁重试和watchdog机制"></a>锁重试和watchdog机制</h5><p>这部分视频是源码，没看懂</p>
<img src="F:\Typora\img\image-20240324103427760.png" alt="image-20240324103427760" style="zoom:67%;" />

<p>waitTime等待时间，在等待时间结束前，都会进行重试</p>
<p>第二个是超时释放时间，不想设置则-1，默认-1不设置</p>
<p>当你没有设置锁释放时间时，在获取锁的时候会设置看门狗时间，30s作为释放时间</p>
<p>好像会更新，会重置有效期，永不过期</p>
<p>锁释放的时候，取消自动更新有效期</p>
<p>看门狗：每过一段时间10s就重置有效期，一直执行</p>
<p>ttl&#x3D;null，获取锁成功</p>
<p>有看门狗机制就不建议设置过期时间了</p>
<img src="F:\Typora\img\image-20240324110614317.png" alt="image-20240324110614317" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240324111031720.png" alt="image-20240324111031720" style="zoom:67%;" />



<h5 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h5><p>当主节点中有锁，尚未同步给从节点时，主节点挂了，此时就有发生别的线程趁虚而入的问题</p>
<img src="F:\Typora\img\image-20240324112906452.png" alt="image-20240324112906452" style="zoom:67%;" />

<p>使用连锁</p>
<p>建立多个主节点，只有每个主节点都没有锁，才可以获取</p>
<p>只要有一个有锁，就获取失败</p>
<p>这三个视频建议有时间重新看，源码我没看懂，也没听懂</p>
<img src="F:\Typora\img\image-20240324123254885.png" alt="image-20240324123254885" style="zoom:67%;" />





<h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h3><p>添加多个线程 ，分线程进行工作</p>
<p>利用消息队列进行异步操作</p>
<p>可将判断库存是否充足以及用户是否购买过这两步操作，在redis中执行</p>
<p>利用string保存库存</p>
<p>利用set保存用户id</p>
<p>key都是优惠券的id</p>
<img src="F:\Typora\img\image-20240523172741517.png" alt="image-20240523172741517" style="zoom:67%;" />



<p>如何开启异步线程</p>
<p>将下单信息保存到阻塞队列中</p>
<p>阻塞队列：当一个线程往阻塞队列中拿数据时，如果队列为空，则这个线程会被阻塞，直到队列不为空时才被唤醒并拿数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    orderTasks.add(VoucherOrder);<span class="comment">//保存优惠券到阻塞队列</span></span><br></pre></td></tr></table></figure>



<p>开启独立线程</p>
<p>准备线程池，开启独立任务</p>
<p>线程池，这里是获取单线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p>创建一个内部类实现Runnable来执行线程任务，没看懂了，不过以后使用mq</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>了解即可，实际用mq</p>
<p>可以通过redis的list数据结构模拟实现，还可以通过brpop命令实现阻塞，但只能一个消费者获取</p>
<p>为了实现多个消费者获取</p>
<img src="F:\Typora\img\image-20240525144326663.png" alt="image-20240525144326663" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240525144437790.png" alt="image-20240525144437790" style="zoom:67%;" />

<p>为了解决消息丢失的问题</p>
<img src="F:\Typora\img\image-20240525150101521.png" alt="image-20240525150101521" style="zoom:67%;" />

<p>strem类型的消息是永久保存</p>
<img src="F:\Typora\img\image-20240525152241681.png" alt="image-20240525152241681" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240525152512793.png" alt="image-20240525152512793" style="zoom:67%;" />





<h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h3 id="完善点赞功能"><a href="#完善点赞功能" class="headerlink" title="完善点赞功能"></a>完善点赞功能</h3><p>可以利用set来判断当前用户是否点赞</p>
<p>此处采用zset，然后判断分数是否存在来判断用户是否点赞</p>
<img src="F:\Typora\img\image-20240526141615215.png" alt="image-20240526141615215" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">        <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">        <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h3><p>利用zset，点赞的人的时间戳为分数</p>
<p>返回zset里面，最早的几个人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h3><p>同样可以用set来保存某个用户的关注集合</p>
<p>如果是关注就加入到关注集合里</p>
<p>如果是取关就从关注集合中移除</p>
<p>共同关注</p>
<p>则是可以根据用户的关注集合，利用set方法里求交集的方法就可以获取共同关注的id集合了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h3><img src="F:\Typora\img\image-20240526161347517.png" alt="image-20240526161347517" style="zoom:67%;" />

<p>基于推模式实现关注推送功能</p>
<p>利用zset来给粉丝推送博客</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现滚动分页，每次查询从上次的最后一个数据的下一个数据开始，查n个数据来进行分页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h3><h3 id="实现附近商户的功能"><a href="#实现附近商户的功能" class="headerlink" title="实现附近商户的功能"></a>实现附近商户的功能</h3><p>好像一般采用es来实现比较好</p>
<img src="F:\Typora\img\image-20240527132828678.png" alt="image-20240527132828678" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">        Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 返回数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.计算分页参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">            .search(</span><br><span class="line">                    key,<span class="comment">//从这个集合里</span></span><br><span class="line">                    GeoReference.fromCoordinate(x, y),<span class="comment">//圆心</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),<span class="comment">//半径</span></span><br><span class="line">                    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)<span class="comment">//返回0-end之间的数据</span></span><br><span class="line">            );</span><br><span class="line">    <span class="comment">// 4.解析出id</span></span><br><span class="line">    <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">        <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">    Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">// 4.3.获取距离</span></span><br><span class="line">        <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">        distanceMap.put(shopIdStr, distance);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h3><img src="F:\Typora\img\image-20240527154228555.png" alt="image-20240527154228555" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>统计连续签到天数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>适合用于uv统计</p>
<img src="F:\Typora\img\image-20240527163415703.png" alt="image-20240527163415703" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240527163432131.png" alt="image-20240527163432131" style="zoom:67%;" />













<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>同步调用：耦合度高，一次只能调用一个服务，性能和吞吐能力低，资源浪费，可能出现级联失败，不适合高并发；实时性好</p>
<p>同步存在的问题：耦合度高，性能下降，资源浪费，级联失败（如果提供者出现问题，调用者也会出现问题）</p>
<p>异步调用：服务解耦，性能提升，吞吐量提高，没有强依赖，不担心级联失败，流量消峰；依赖broker，结构复杂，不好管理</p>
<p>异步调用是事件驱动模式，缺点是依赖broker，结构复杂，不好管理</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>概念</p>
<p>channel：操作mq的工具，exchang：路由消息到队列中，queue：缓存信息，virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</p>
<p>基本消息队列</p>
<p>三个角色：publisher，queue，consumer</p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>使用需要在maven中引入spring—amqp依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot</span><br><span class="line">    &lt;artifactId&gt;spring-boot-statter-amqp&gt;</span><br></pre></td></tr></table></figure>

<p>在配置文件添加mq信息</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">rabbitmq:</span></span><br><span class="line">		<span class="attr">host:</span> <span class="string">rabbitmq的ip地址</span></span><br><span class="line">		<span class="attr">port:</span> <span class="string">端口</span></span><br><span class="line">		<span class="attr">virtual-host:</span> <span class="string">虚拟主机</span></span><br><span class="line">		<span class="attr">username:</span></span><br><span class="line">		<span class="attr">password:</span></span><br><span class="line">		<span class="attr">listener:</span></span><br><span class="line">			<span class="attr">simple:</span> <span class="string">队列</span></span><br><span class="line">				<span class="attr">prefetch:</span> <span class="number">1</span> <span class="string">每次只能获取一条消息，处理完成之后才能获取下一个消息</span></span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<p>发送前需确保队列存在</p>
<img src="F:\Typora\img\image-20231221000011229.png" alt="image-20231221000011229" style="zoom:60%;" />

<p>接收消息</p>
<img src="F:\Typora\img\image-20231221001013597.png" alt="image-20231221001013597" style="zoom:67%;" />

<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>实现方式是加入了交换机exchange</p>
<p>交换机作用：</p>
<p>接收生产者发送的消息；</p>
<p>将消息按照规则路由到与之绑定的队列；</p>
<p>不能缓存消息，路由失败则消息丢失</p>
<img src="F:\Typora\img\image-20231221103416435.png" alt="image-20231221103416435" style="zoom:60%;" />

<h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>声明绑定关系交换机</p>
<img src="F:\Typora\img\image-20231221104237105.png" alt="image-20231221104237105" style="zoom:60%;" />

<p>发送消息要指定交换机，发送给绑定的每一个队列，广播订阅</p>
<img src="F:\Typora\img\image-20231221105020265.png" alt="image-20231221105020265" style="zoom:67%;" />

<p>接收消息和入门一样，指定队列即可</p>
<h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p>可以模拟fanout exchange</p>
<img src="F:\Typora\img\image-20231221105854503.png" alt="image-20231221105854503" style="zoom:67%;" />

<p>接收消息，指定队列，交换机，暗号</p>
<img src="F:\Typora\img\image-20231221110113975.png" alt="image-20231221110113975" style="zoom:67%;" />

<p>发送消息，可将消息发送到该交换机下绑定了对应routingkey的队列中，可实现广播订阅，也可实现分级订阅</p>
<img src="F:\Typora\img\image-20231221110909743.png" alt="image-20231221110909743" style="zoom:67%;" />

<h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p>与directExchange的区别在于topicExchange支持通配符</p>
<img src="F:\Typora\img\image-20231221112014678.png" alt="image-20231221112014678" style="zoom:67%;" />

<p>接收消息与directExchange相似</p>
<img src="F:\Typora\img\image-20231221112258098.png" alt="image-20231221112258098" style="zoom:67%;" />

<p>发送消息也一样</p>
<img src="F:\Typora\img\image-20231221112407476.png" alt="image-20231221112407476" style="zoom:67%;" />

<h4 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h4><img src="F:\Typora\img\image-20231221125755045.png" alt="image-20231221125755045" style="zoom:67%;" />

<p>这样就可以将任意类型当作消息发送了，同样地，接收消息也需要进行序列化</p>
<img src="F:\Typora\img\image-20231221130208998.png" alt="image-20231221130208998" style="zoom:67%;" />

<p>注意发送方和接收方要使用同样的消息转换器，不能一个用springAMQP自带的jdk序列化，一个用json序列化</p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>动力节点视频</p>
<p>队列的作用？</p>
<p>存储消息，为什么要存消息？</p>
<p>异步，削峰限流，解耦</p>
<p>生产者——broker（经理人）——消费者</p>
<p>主题topic：消息的区分，分类</p>
<p>主题是虚拟的结构</p>
<p>主题里的队列Queue是真实存在的，消息的内容</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>如果一个broker挂掉则不可用了，此时是单机版的，因此不是高可用方案</p>
<p>name server：注册路由中心</p>
<p>每一个broker将自己的ip等配置信息登记在name server上</p>
<p>生产者发消息时，先连接name server，name server在其管理的broker里选择一个broker分配给生产者进行消息传递</p>
<p>此时实现写的高可用</p>
<p>而对于消费者，它不知道连接哪个broker可以接收消息，也是去连接name server进行询问对应的主题在哪个broker中，</p>
<p>name server将消费者所需要的broker信息传递给消费者，消费者进行连接然后消费</p>
<p>此时实现读的高可用</p>
<h3 id="broker的主从机"><a href="#broker的主从机" class="headerlink" title="broker的主从机"></a>broker的主从机</h3><p><img src="F:\Typora\img\image-20240301221023133.png" alt="image-20240301221023133"></p>
<p>建立多个broker实现主从机，每个broker即是主机也是从机，往一组主从机中发送消息，消息会同步到组里的每一个broker中，消费者可在任意一个broker中读取消息进行消费</p>
<p>如果是常规安装rocketmq</p>
<p>解压完之后需要对配置文件进行修改</p>
<img src="F:\Typora\img\image-20240314123229376.png" alt="image-20240314123229376" style="zoom:67%;" />

<p> 然后如果在虚拟机中运行，内存又太小的话，在bin文件夹中修改runserver文件和runbroker文件中内存的大小</p>
<img src="F:\Typora\img\image-20240314134043229.png" alt="image-20240314134043229" style="zoom:67%;" />

<p>等等</p>
<p>先配置nameserver和broker，再配置dashboard</p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><img src="F:\Typora\img\image-20240314140156051.png" alt="image-20240314140156051" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240314140623538.png" alt="image-20240314140623538" style="zoom:67%;" />

<p>生产者</p>
<img src="F:\Typora\img\image-20240314142813297.png" alt="image-20240314142813297" style="zoom:67%;" />

<p> 消费者</p>
<p>目前来说，消费者监听器的方法中，list只有一个消息</p>
<img src="F:\Typora\img\image-20240314144339052.png" alt="image-20240314144339052" style="zoom:67%;" />

<p> 下面还有</p>
<img src="F:\Typora\img\image-20240314152730946.png" alt="image-20240314152730946" style="zoom:67%;" />

<p>生产者组可以给多个主题发送消息</p>
<p>但是消费者组内的消费者订阅关系必须保持一致，一般不会出现一个消费者组订阅多个主题的情况</p>
<p>但gpt说RocketMQ中一个消费者组是可以订阅多个主题的</p>
<p>暂时可理解为一个消费者组只能订阅一个或多个主题，但一个消费者内的消费者都订阅一样的主题</p>
<p>如果多个消费者组同时订阅一个主题，当有消息时，是以组为单位，每个组都得到一份消息</p>
<p>至于消费者组内给哪个消费者，取决于消费者组是采取了广播还是负载均衡策略等</p>
<p>生产者给一个主题发送消息时，主题中的多个队列采用轮询的方式接收消息</p>
<p>而对于消费者来说，是采取将队列分给消费者的策略，每个消费者只能接受来自对应队列的消息</p>
<p>在消费者数量不多时，一个消费者可以接收多个队列的消息</p>
<p>一个队列的消息只能给一个消费者接收</p>
<p>不能接受其他队列的消息，当消费者的数量大于队列的数量时，就存在有些消费者永远没有消息</p>
<p>因此队列的数量应大于等于消费者的数量</p>
<h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><img src="F:\Typora\img\image-20240314153209352.png" alt="image-20240314153209352" style="zoom:67%;" />

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><h4 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h4><img src="F:\Typora\img\image-20240314155100159.png" alt="image-20240314155100159" style="zoom:67%;" />

<h4 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h4><p>异步消息使用于对响应时间敏感的场景，优先继续继续接下来的代码，发送完以后会有一个异步消息通知</p>
<img src="F:\Typora\img\image-20240314155946664.png" alt="image-20240314155946664" style="zoom:67%;" />



<h4 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h4><p>只管发，至于你收不收到我不管</p>
<img src="F:\Typora\img\image-20240314160129694.png" alt="image-20240314160129694" style="zoom:67%;" />

<p>对于日志的处理</p>
<p>开发环境下，日志输出在控制台</p>
<p>生产环境下，日志输出在文件里&#x2F;mysql&#x2F;Es</p>
<p>当日志过多时，可考虑搭建一个日志服务器，通过单向消息将日志发送到服务器中然后再发送到mysql&#x2F;es中 </p>
<h4 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h4><p><img src="F:\Typora\img\image-20240314162459255.png" alt="image-20240314162459255"></p>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>将需要顺序消费的消息放在同一个队列里，顺序消费即可保证消息的顺序</p>
<p>顺序消息的发送，则需要在send方法中再添加两个参数</p>
<p>一个参数是队列选择器，采用匿名函数的方法创建</p>
<p>一个是排序参数，如此例中的订单号，会使得队列选择器中的方法按照该参数进行队列选择</p>
<img src="F:\Typora\img\image-20240314205527019.png" alt="image-20240314205527019" style="zoom:67%;" />

<p>其他各种类型的消息的消费基本都一致，是采取并发模式的，</p>
<p>而顺序消息的顺序则需要采取单线程，采取顺序模型消费</p>
<p>如果消费失败了，则会进行重试，重试一定次数之后就会放弃</p>
<p>并发模式最多重试16次，将消息放到死信队列</p>
<p>单线程模式最多重试int的最大值次数，接近21亿</p>
<img src="F:\Typora\img\image-20240314210152126.png" alt="image-20240314210152126" style="zoom:67%;" />



<h4 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h4><p>list集合中的消息应该是<strong>同一个主题</strong>的，是多个消息都发送到同一个队列中</p>
<img src="F:\Typora\img\image-20240314165134910.png" alt="image-20240314165134910" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240314165216545.png" alt="image-20240314165216545" style="zoom:67%;" />



<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>视频不讲</p>
<img src="F:\Typora\img\image-20240314210559141.png" alt="image-20240314210559141" style="zoom:67%;" />





<h3 id="tag过滤"><a href="#tag过滤" class="headerlink" title="tag过滤"></a>tag过滤</h3><img src="F:\Typora\img\image-20240314230800548.png" alt="image-20240314230800548" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240314232249299.png" alt="image-20240314232249299" style="zoom:67%;" />

<p>什么时候使用topic，什么时候该用tag</p>
<img src="F:\Typora\img\image-20240314232444652.png" alt="image-20240314232444652" style="zoom:67%;" />

<p>对于第四个，比如有的需要立马消费，但由于topic中的先进先出，导致其不能被迅速消费</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><img src="F:\Typora\img\image-20240314232955860.png" alt="image-20240314232955860" style="zoom:67%;" />

<p>key的作用就是给消息生成一个我们自己创建的唯一标识</p>
<p>如果给多个消息带同一个key，mq也是成功的，因此我们需要自己确保key的唯一</p>
<img src="F:\Typora\img\image-20240314234002212.png" alt="image-20240314234002212" style="zoom:67%;" />





<h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h3><p>消息会重复的情况：1、生产者多次投递了，2、消费者方因为扩容重试导致消息被两个消费者消费</p>
<p>解决方法</p>
<p>通过key的唯一性，每次消费前判断该key是否来过了</p>
<p>使用redis&#x2F;mysql来存储key</p>
<p>最好用redis</p>
<p>可以通过幂等性进行去重，什么是幂等性？？？</p>
<p>幂等性：多次操作所产生的影响均和第一次操作产生的影响相同</p>
<p>解决的方案</p>
<p>发送方需要给消息携带一个唯一标记</p>
<p>消费者方需要控制消息的幂等性</p>
<p>查询key是否存在，如果存在就返回，如果不存在就新增数据</p>
<p>但这样子是线程不安全的，需要运用<strong>redis的setnx方法</strong>进行加锁</p>
<p>也可以将修改为，不查询直接进行插入key操作，如果成功就继续执行</p>
<p>否则报错返回</p>
<p>解决重复消费（mysql）：先建一个去重表以及表中的唯一索引</p>
<h3 id="消息重试和死信消息解决方案"><a href="#消息重试和死信消息解决方案" class="headerlink" title="消息重试和死信消息解决方案"></a>消息重试和死信消息解决方案</h3><p>并发默认重试16次，顺序模式接近无限次</p>
<p>我们是可以手动设置重试次数，不用太大，一般五次</p>
<p>在消费者中设定对于同一条消失的重新消费次数，超过就不再接收该消息，并将它扔到死信消息队列里</p>
<p>当业务报错了，返回null或者返回RECONSUME_LATER时，都是进行消息重试</p>
<p>重试的时间间隔是和延迟时间一致的，且从第三个级别，即10s开始</p>
<p>如果重试了16次都是失败的，则认为这是一个死信消息</p>
<p>该死信消息的主题是%DLQ%消费者组名称</p>
<p>第一种处理方案：</p>
<p>然后创建一个消费者组专门消费该死信消息</p>
<p>然后这个消费者组不会处理死信消息，而是通知人工来处理，因为自己处理也是失败的，故采用人工 </p>
<p>第二种处理方案：</p>
<p>在消费者中采用try-catch方法，当出错时就在catch中进行相应的处理</p>
<p>当重试到一定的次数之后，直接签收该消息 </p>
<p>推荐使用第二个方案，第一个需要建立大量的消费者组，麻烦</p>
<p>记得若是业务逻辑报错了，删除去重表中对应的记录</p>
<h3 id="boot操作mq"><a href="#boot操作mq" class="headerlink" title="boot操作mq"></a>boot操作mq</h3> <img src="F:\Typora\img\image-20240315193621971.png" alt="image-20240315193621971" style="zoom:67%;" />

<p>这个需要4.9.+的rockemqt client版本</p>
<p>最后视频使用的是2.2.2版本的</p>
<h4 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h4><p>对于生产者来说，只需要导入rocketmq相关依赖后，在配置文件中进行设置</p>
<img src="F:\Typora\img\image-20240315200433632.png" alt="image-20240315200433632" style="zoom:67%;" />

<p>然后操作RocketMQTemplate对象，执行相应的方法即可发送消息</p>
<p>基本上各种类型的消息发送方式都与之前的一致</p>
<p>除了延迟消息有点区别</p>
<p>没法像之前的一样给消息设置延迟时间，因为是不一样的message类</p>
<p>需要先设置一个连接超时时间，才能设置延迟时间</p>
<img src="F:\Typora\img\image-20240315202702959.png" alt="image-20240315202702959" style="zoom:67%;" />

<p>顺序消息也不一样</p>
<p>因为顺序消息还是需要将一组消息都发到同一个队列中去，消费者需要单线程消费</p>
<p>第三个参数就是之前的，根据哈希值选择队列</p>
<img src="F:\Typora\img\image-20240315203610734.png" alt="image-20240315203610734" style="zoom:67%;" />

<p>需要单独写一个消费者给顺序消息</p>
<img src="F:\Typora\img\image-20240315204205492.png" alt="image-20240315204205492" style="zoom:67%;" />





<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>对于消费者来说，则多了一些操作</p>
<p>在项目中不需要像上面一样将消费者挂起，因为web容器不会自己停下来</p>
<p>首先同样是在配置文件中进行配置</p>
 <img src="F:\Typora\img\image-20240315200641224.png" alt="image-20240315200641224" style="zoom:67%;" />

<p>为什么不在这里配置消费者组呢？</p>
<p>是因为一个boot项目可以有多个消费者，在这里配置之后，所有消息就会被同一个消费者进行消费</p>
<p>但一般来说一个项目就是一个消费者</p>
<p>消费者需要一个监听器类，并将其加入到容器之中</p>
<img src="F:\Typora\img\image-20240315203152921.png" alt="image-20240315203152921" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240315203219717.png" alt="image-20240315203219717" style="zoom:67%;" />



<h4 id="携带tag"><a href="#携带tag" class="headerlink" title="携带tag"></a>携带tag</h4><p>生产者这里携带tag的格式是，topic:tag</p>
<img src="F:\Typora\img\image-20240315204532435.png" alt="image-20240315204532435" style="zoom:67%;" />

<p>消费者有点区别，多了注解参数</p>
<img src="F:\Typora\img\image-20240315204857662.png" alt="image-20240315204857662" style="zoom:67%;" />

<p>还有一种特殊的携带tag的模式，很少用，知道就可以，默认不支持，需要在配置文件开启对应功能</p>
<img src="F:\Typora\img\image-20240315205105937.png" alt="image-20240315205105937" style="zoom:67%;" />

<p>消费者中的过滤条件，可以是大于，也可以是这样子的集合模式，类似sql语句的判断</p>
<img src="F:\Typora\img\image-20240315205132940.png" alt="image-20240315205132940" style="zoom:67%;" />

<h4 id="携带key"><a href="#携带key" class="headerlink" title="携带key"></a>携带key</h4><p>对于key来说，是需要将key写在消息头里的</p>
<img src="F:\Typora\img\image-20240315205554801.png" alt="image-20240315205554801" style="zoom:67%;" />



<h3 id="消费的两种模式"><a href="#消费的两种模式" class="headerlink" title="消费的两种模式"></a>消费的两种模式</h3><p>两种模式：负载均衡和广播模式 </p>
<p>同样是可以在注解中进行配置，默认集群模式，即负载均衡</p>
<p>把消息根据队列进行负载均衡给消费者</p>
<p>注意：消息会以组为单位，每个组都可以得到一份，大概是广播吧</p>
<p>广播模式不会进行重试，消费成功与否都不会管，点位以及差值也不会管</p>
<img src="F:\Typora\img\image-20240316110641737.png" alt="image-20240316110641737" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240316111716082.png" alt="image-20240316111716082" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240316112606232.png" alt="image-20240316112606232" style="zoom:67%;" />





<h3 id="消费堆积问题"><a href="#消费堆积问题" class="headerlink" title="消费堆积问题"></a>消费堆积问题</h3><p>消息堆积：即差值很大，mq中存储了很多未消费的消息、</p>
<p>队列差值大于10w就要小心堆积了</p>
<p>一般认为单条队列消息差值》&#x3D;10w时算堆积问题</p>
<h4 id="问题情况1：生产速度远远大于消费速度"><a href="#问题情况1：生产速度远远大于消费速度" class="headerlink" title="问题情况1：生产速度远远大于消费速度"></a>问题情况1：生产速度远远大于消费速度</h4><p>解决方案</p>
<p>1、生产方可以做业务限流</p>
<p>2、增加消费者数量，但是注意消费者数量小于等于队列数量，否则再多也没用，队列数量不要频繁改，由运维决定</p>
<p>如果要缩小队列的数量，记得不要在没消费完的时候缩小，否则会消息丢失</p>
<p>3、提高线程数量</p>
<p>视频里线程数量为20，因此填40</p>
<img src="F:\Typora\img\image-20240316122714176.png" alt="image-20240316122714176" style="zoom:67%;" />

<p>题外话：线程池可分为IO密集型（读写操作，cpu转一下，磁盘转很久）和CPU密集型（计算操作，cpu转很久，磁盘转一下）</p>
<p>创建线程池好像有7个参数，但我不知道</p>
<p>对于IO密集型，最大线程数量可以写2 * n，n是你电脑上的线程数</p>
<p>对于CPU密集型，最大线程数量可以写n+1</p>
<p>可通过方法获取n</p>
<img src="F:\Typora\img\image-20240316122623376.png" alt="image-20240316122623376" style="zoom:50%;" />

<h4 id="问题情况2：消费者消费出现问题"><a href="#问题情况2：消费者消费出现问题" class="headerlink" title="问题情况2：消费者消费出现问题"></a>问题情况2：消费者消费出现问题</h4><p>排查消费者程序的问题</p>
<p>当消息堆积太多又不想要的时候，可以跳过堆积，自己不要点，让别人担责嘻嘻嘻</p>
<p>重置消费点位，可以回溯到以前的时间点，重新消费，这样子可以补救不小心跳过堆积的情况</p>
<h3 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h3><p>消息最后是会放在磁盘上的</p>
<p>broker拿到消息后会将消息持久化到磁盘上</p>
<p>刷盘分为同步刷盘和异步刷盘</p>
<p>同步刷盘采取顺序读取的方式，会将接收结果返回给消费者，性能不好</p>
<p>异步刷盘则会先将消息存到buffer（内存）里，当buffer的容量达到某个值时，才会将buffer里的消息存到磁盘里</p>
<p>同步消息一般不会有丢失问题</p>
<p>而异步消息因为是存在内存里的，如果断电会出现丢失问题</p>
<p>如何解决呢？</p>
<p>我们自己实现持久化，将消息持久化到mysql数据库中，或者通过日志的方式记录在文件</p>
<p>因为我们会给消息携带一个key，可以将key’存到mysql中</p>
<p>我们也可以通过消息轨迹来看查询一个消息的活动状态，查看其是什么时候发送的，什么时候被消费等信息</p>
<img src="F:\Typora\img\image-20240316154927386.png" alt="image-20240316154927386" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240316154517580.png" alt="image-20240316154517580" style="zoom:67%;" />

<p>消息跟踪机制如下</p>
<p>在broker中开启跟踪需要先关闭broker，采取kill 线程id的方式</p>
<p>或者kill -15 线程id</p>
<p>千万不要-9，这个是暴力杀死</p>
<img src="F:\Typora\img\image-20240316155054107.png" alt="image-20240316155054107" style="zoom:67%;" />

<p>上面的生产者和消费者是在yml配置文件里改的，broker则是在conf配置文件，通过命令行修改</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>因为我们以上操作没有进行登录，别人只要知道了你的ip地址就可以访问你的mq了，因此很危险</p>
<p>如何解决呢</p>
<p>同样是先修改broker的配置文件</p>
<p>在里面开启aclEnable&#x3D;true</p>
<p>然后修改plain_acl.yml，&#x2F;&#x2F;开启ip白名单，不知道这样子说对不对，反正需要修改</p>
<p>然后在生产者配置文件中输入账号和密码，这样子就可以发送消息了</p>
<p>消费者同样需要在配置文件填写账号密码</p>
<p>而我们的dashboard面板，想要连接nameserver然后查看broker</p>
<p>此时也是连接失败的，需要进行配置</p>
<p>在其application.properties中填写broker的acl账号和密码，开启user账号登录，然后就可以读取user.properties中已登记的账号密码</p>
<h3 id="rocketmq设计"><a href="#rocketmq设计" class="headerlink" title="rocketmq设计"></a>rocketmq设计</h3><p>可通过文档来了解rocketmq，挺复杂的</p>
<p>生产者发送消息时，并不是直接发送到队列中，而是先发送到一个Commitlog的连续存储空间里</p>
<p>然后再把消息在此里面的<strong>偏移量，消息大小，tag信息</strong>等发送到对应主题的队列中</p>
<p>消费者根据这三个消息，从Commitlog查找消息进行消费</p>
<h3 id="秒杀业务"><a href="#秒杀业务" class="headerlink" title="秒杀业务"></a>秒杀业务</h3><p>可使用在很短的时间内处理大量请求的情况</p>
<p>并发：多个任务在同一个时间段执行</p>
<p>并行：多核cpu上，多个任务在同一时刻执行</p>
<p>接口的处理时间越短，吞吐量QPS越高</p>
<p>如果有多个tomcat（几千吞吐量，大概五千左右），可以利用nginx进行负载均衡</p>
<p>Nginx可以最多承受5w&#x2F;s左右的吞吐量</p>
<p>如果超过5w，在nginx前面设置一个Lvs&#x2F;F5的硬件（30w&#x2F;s）顶住压力，然后再负载均衡给nginx集群</p>
<p>如果又超出了这个范围，如100w&#x2F;s，把流量根据某种方式拆分掉，不同分组的流量发送到不同的机房里</p>
<p>采用DNS轮询策略，通过dns服务器，选择一个ip地址来接收流量</p>
<h4 id="如何从软件方面提高吞吐量"><a href="#如何从软件方面提高吞吐量" class="headerlink" title="如何从软件方面提高吞吐量"></a>如何从软件方面提高吞吐量</h4><p>尽量减少接口的处理时间（优化接口的响应时间）</p>
<p>优化方法：</p>
<p>能异步就异步</p>
<p>减少io，如统一查询数据库，统一写数据库，一次性操作数据库，不要分多次</p>
<p>能return就立马返回，不满足条件直接返回</p>
<p>加锁时，力度尽可能小</p>
<p>数据库事务方面，事务控制力度尽可能小</p>
<p>同时前端应配合我们，弄个验证码，拼图滑块之类的进行分流</p>
<h4 id="秒杀流程"><a href="#秒杀流程" class="headerlink" title="秒杀流程"></a>秒杀流程</h4><p>请求进来之后，尽量不要一进来就操作数据库，例如秒杀商品时，可以先判断库存够不够（库存放到redis，使用redis的lua脚本判断库存是否足够，如果足够生成订单号、用户id等信息放到MQ，异步刷新到mysql中）</p>
<p>如果库存够则执行业务，不够就直接返回，将库存信息同步到redis（大概8w读，6w写）中，在redis中判断库存够不够，够则进行预扣减，然后再操作数据库</p>
<p>我们可以将操作数据库这一步异步化，再建一个程序</p>
<p>只要redis预扣减成功之后，就将订单的相关信息发送到mq里，只有mq返回收到消息，就返回。</p>
<p>然后通过mq进行异步操作数据库，创建一个消费者来消费消息，扣减数据库中的库存以及其他操作</p>
<p>两个服务程序，一个发送消息，一个消费消息</p>
<img src="F:\Typora\img\image-20240317114754855.png" alt="image-20240317114754855" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240317120800925.png" alt="image-20240317120800925" style="zoom:67%;" />

<p>用户下单后，将消息存到mq里，但用户的订单里是不能立马看到订单的，因为mq的处理需要时间，通过减少消息数量，减少每个消息的等待时间</p>
<p>上面的布隆过滤器可以使用redis进行替代</p>
<p>还可以通过通过redis进行用户去重，适用于限定一个用户只能抢购一次的情景</p>
<p>利用redis的setnx方法 ，可以提高程序的并发量，用户已经来过了就直接返回</p>
<h4 id="web发送下单消息"><a href="#web发送下单消息" class="headerlink" title="web发送下单消息"></a>web发送下单消息</h4><p>真实的项目中，秒杀下单时，可以通过token获取用户id信息等，因此不需要传用户id这个参数</p>
<p>去重时，可以通过<strong>用户id-商品id</strong>这两个组合起来，作为去重key（uk&#x3D;uniquekey）</p>
<p>setnx在Stringredistemplate中的方法是setifabsent</p>
<p>这个一般用lua脚本做，保证原子操作</p>
<p>如果是每天都可以抢一次</p>
<p>则把<strong>日期和用户id-商品id组合起来</strong><img src="F:\Typora\img\image-20240317133129977.png" alt="image-20240317133129977" style="zoom:67%;" /></p>
<p>在预扣减的时候，注意线程安全</p>
<p>最好查库存与扣减库存一步完成</p>
<p>或者采取直接减的操作，库存扣减完再检查是否可以购买</p>
<img src="F:\Typora\img\image-20240317132505846.png" alt="image-20240317132505846" style="zoom:67%;" />

<p>redis是单线程的，可以保证线程安全，不会一起减，而先查后减，可能查完还没减，另一个也已经开始查完了，导致超卖</p>
<p>尽管会出现库存一直被减的情况，但对业务没有影响</p>
<p>然后通过mq发送异步消息</p>
<img src="F:\Typora\img\image-20240317132952960.png" alt="image-20240317132952960" style="zoom:67%;" />



<h4 id="秒杀服务消费消息"><a href="#秒杀服务消费消息" class="headerlink" title="秒杀服务消费消息"></a>秒杀服务消费消息</h4><p>写一个定时任务，通过定时任务每天将mysql的库存同步到redis中</p>
<p>@PostConstruct注解可以使方法在项目启动后以及类属性注入完毕后，执行该方法</p>
<p>这个注解是bean的注解，是在bean的生命周期里的</p>
<img src="F:\Typora\img\image-20240317145216502.png" alt="image-20240317145216502" style="zoom:67%;" />

<p>然后就可以创建消费者了</p>
<p>在消费者里先获取用户和商品的id，然后就调用impl实现类里对应的方法进行操作</p>
<p>扣减库存和写订单表这两个操作要保证原子性，因此使用@Transactional注解，并写好回滚异常</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>单机锁</p>
<p>如果在impl开启事务后加锁，之后仍然会出现超卖问题</p>
<p>如果开事务再加锁，如这样子，仍然会出现超卖问题</p>
<img src="F:\Typora\img\image-20240317165529918.png" alt="image-20240317165529918" style="zoom:67%;" />

<p>可以在消费消息中调用impl实现类的方法时加锁</p>
<p>但加锁的力度有点大，时间比较长</p>
<p>这样子的话，从mq中拿消息时是异步的，多线程的，但处理的时候是单线程的</p>
<p>应该是先加锁在开事务，不能是先开事务再加锁</p>
<img src="F:\Typora\img\image-20240317165249558.png" alt="image-20240317165249558" style="zoom:67%;" />

<p>如果有多个机器的话，是锁不住的，因此不是分布式锁，只能在单机玩</p>
<h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>分布式锁</p>
<p>找一个中间人来协调多个机器的访问请求</p>
<p>可以使用mysql（行锁），redis实现</p>
<p>mysql行锁例子，并发不高可以玩，并发高不建议用，因为压力全给数据库了</p>
<img src="F:\Typora\img\image-20240317171513862.png" alt="image-20240317171513862" style="zoom:67%;" />

<p>在没有执行commit语句前，其他都会被阻塞</p>
<p>此时就不用像上面一样在mq消费时加锁</p>
<p>依赖total_stocks &#x3D; total_stocks - 1施加行锁，此处也应该有大于等于0的条件</p>
<img src="F:\Typora\img\image-20240317171938708.png" alt="image-20240317171938708" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240317190133071.png" alt="image-20240317190133071" style="zoom:67%;" />



<h5 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h5><p>通过setnx命令，好像使用redission进行分布式锁更好</p>
<p>对key设置一个过期时间比较好，防止程序挂了或者阻塞之后，key一直不释放</p>
<img src="F:\Typora\img\image-20240317193104135.png" alt="image-20240317193104135" style="zoom:67%;" />

<p>这里存在的问题是当一个线程第一次拿锁失败时，会进入等待队列中</p>
<p>那如何唤醒该线程，使其重新拿锁呢</p>
<p>使其自旋，并在拿锁失败时，等待200ms再去拿</p>
<p>ZX_TIME是10000ms，即10s，每次休息200ms再尝试重新拿锁，都没拿成功则是失败了</p>
<p>ZX_TIME时间建议稍微长一些，视频中10s，导致最后有18个退出了，while（true）也是可以的，但这样没拿到锁就不会退出，不建议</p>
<p>睡眠200ms，也有点久了，也可能因为这里，导致有18个退出</p>
<p>实际业务根据需求设置时间，好像建议使用redission来控制时间</p>
<img src="F:\Typora\img\image-20240317193422337.png" alt="image-20240317193422337" style="zoom:67%;" />

<p>以上代码还存在一个缺陷，即没有退出循环</p>
<img src="F:\Typora\img\image-20240317193941147.png" alt="image-20240317193941147" style="zoom:67%;" />

<p>try里面return了，finally也会执行，先执行再返回</p>
<h3 id="秒杀总结"><a href="#秒杀总结" class="headerlink" title="秒杀总结"></a>秒杀总结</h3><img src="F:\Typora\img\image-20240317201322909.png" alt="image-20240317201322909" style="zoom:67%;" />





<h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>一款非常强大的开源搜索引擎，擅长海量数据的搜索，分析和计算</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>空间换时间</p>
<img src="F:\Typora\img\image-20231221134501461.png" alt="image-20231221134501461" style="zoom:67%;" />

<p>文档数据会被序列化为json格式存储起来</p>
<p>与mysql的对比</p>
<img src="F:\Typora\img\image-20231221134916925.png" alt="image-20231221134916925" style="zoom:67%;" />





<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><h3 id="DDl"><a href="#DDl" class="headerlink" title="DDl"></a>DDl</h3><p>数据定义，用来定义数据库对象</p>
<img src="F:\Typora\img\image-20240530222459696.png" alt="image-20240530222459696" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240530222958418.png" alt="image-20240530222958418" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240530223504646.png" alt="image-20240530223504646" style="zoom:67%;" />

<p>数值类型</p>
<img src="F:\Typora\img\image-20240531103519750.png" alt="image-20240531103519750" style="zoom:67%;" />

<p>精度即浮点数的整个数据长度，标度是小数点后的长度</p>
<p>字符串类型</p>
<img src="F:\Typora\img\image-20240531104603500.png" alt="image-20240531104603500" style="zoom:67%;" />

<p>二进制数据常采用专门的文件进行存储，很少用blob</p>
<p>日期类型</p>
<img src="F:\Typora\img\image-20240531105212635.png" alt="image-20240531105212635" style="zoom:67%;" />

<p>修改表结构</p>
<img src="F:\Typora\img\image-20240531105826151.png" alt="image-20240531105826151" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531105929137.png" alt="image-20240531105929137" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531110109462.png" alt="image-20240531110109462" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531110155992.png" alt="image-20240531110155992" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531110252574.png" alt="image-20240531110252574" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531110709606.png" alt="image-20240531110709606" style="zoom:67%;" />

<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>对数据库中的表数据记录进行增删改操作</p>
<p>insert</p>
<img src="F:\Typora\img\image-20240531112011389.png" alt="image-20240531112011389" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531112056208.png" alt="image-20240531112056208" style="zoom:67%;" />

<p>update</p>
<img src="F:\Typora\img\image-20240531113418354.png" alt="image-20240531113418354" style="zoom:67%;" />

<p>delete</p>
<img src="F:\Typora\img\image-20240531113643153.png" alt="image-20240531113643153" style="zoom:67%;" />

<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>数据查询，用来查询数据库中表的记录</p>
<img src="F:\Typora\img\image-20240531114618982.png" alt="image-20240531114618982" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531114708165.png" alt="image-20240531114708165" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531120044333.png" alt="image-20240531120044333" style="zoom:67%;" />

<p>在处理null值时，可以采用&lt;&#x3D;&gt;”是MySQL中用于比较时处理NULL值的操作符，表示不等于</p>
<p>select name from customer where not referee_id &lt;&#x3D;&gt; 2;</p>
<p>用于从名为customer的表中选择所有referee_id不等于2的顾客的名字。（包括该字段是null值）</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><img src="F:\Typora\img\image-20240531134142056.png" alt="image-20240531134142056" style="zoom:67%;" />

<p>所有null值不参与聚合函数的计算</p>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><img src="F:\Typora\img\image-20240531143046027.png" alt="image-20240531143046027" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531143401127.png" alt="image-20240531143401127" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531143413247.png" alt="image-20240531143413247" style="zoom:50%;" />

<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><img src="F:\Typora\img\image-20240531143615122.png" alt="image-20240531143615122" style="zoom:67%;" />

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><img src="F:\Typora\img\image-20240531143948090.png" alt="image-20240531143948090" style="zoom:67%;" />

<p>limit在每句sql的最后使用</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><img src="F:\Typora\img\image-20240531144924720.png" alt="image-20240531144924720" style="zoom:67%;" />



<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>管理数据库用户，控制数据库的访问权限</p>
<img src="F:\Typora\img\image-20240531145847818.png" alt="image-20240531145847818" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531150351834.png" alt="image-20240531150351834" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531150440618.png" alt="image-20240531150440618" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531150703792.png" alt="image-20240531150703792" style="zoom:67%;" />



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是指一段可以直接被另一段程序调用的程序或代码</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><img src="F:\Typora\img\image-20240531152256995.png" alt="image-20240531152256995" style="zoom:67%;" />

<p>substring的索引从1开始</p>
<p> CHAR_LENGTH(str) 函数：用于返回字符串的长度</p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><img src="F:\Typora\img\image-20240531153108552.png" alt="image-20240531153108552" style="zoom:67%;" />

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><img src="F:\Typora\img\image-20240531154226265.png" alt="image-20240531154226265" style="zoom:67%;" />

<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><img src="F:\Typora\img\image-20240531154913450.png" alt="image-20240531154913450" style="zoom:67%;" />



<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><img src="F:\Typora\img\image-20240531161912966.png" alt="image-20240531161912966" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531163210793.png" alt="image-20240531163210793" style="zoom:67%;" />



<p>外键约束</p>
<img src="F:\Typora\img\image-20240531163713413.png" alt="image-20240531163713413" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531171626235.png" alt="image-20240531171626235" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240531171345775.png" alt="image-20240531171345775" style="zoom:67%;" />

<p> <img src="F:\Typora\img\image-20240531171539211.png" alt="image-20240531171539211"></p>
<p>这句话的意思是在删除时一起删除….在更新时一起更新….</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><img src="F:\Typora\img\image-20240601130557352.png" alt="image-20240601130557352" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601130653044.png" alt="image-20240601130653044" style="zoom:67%;" />

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询的是两张表交集的部分</p>
<img src="F:\Typora\img\image-20240601130814202.png" alt="image-20240601130814202" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601131358879.png" alt="image-20240601131358879" style="zoom:67%;" />

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左外连接查询表1（左表）的所有数据以及表1和表2交集部分的数据</p>
<p>右外连接查询表2（右表）的所有数据以及表1和表2交集部分的数据</p>
<img src="F:\Typora\img\image-20240601131609458.png" alt="image-20240601131609458" style="zoom:67%;" />

 <img src="F:\Typora\img\image-20240601131759501.png" alt="image-20240601131759501" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601131955370.png" alt="image-20240601131955370" style="zoom:67%;" />

<p>通常使用左外连接，因为右外连接可以修改为左外连接，只需要更改两张表的顺序即可</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>使用自连接一定要给表起别名</p>
<img src="F:\Typora\img\image-20240601132121257.png" alt="image-20240601132121257" style="zoom:67%;" />

<p>查询交集数据用内连接</p>
<p>查询全部数据用外连接</p>
<img src="F:\Typora\img\image-20240601132656229.png" alt="image-20240601132656229" style="zoom:67%;" />

<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><img src="F:\Typora\img\image-20240601132757213.png" alt="image-20240601132757213" style="zoom:67%;" />

<p>union all是直接将两次查询的结果合并</p>
<p>union是先去重再合并</p>
<p>使用条件：对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><img src="F:\Typora\img\image-20240601133332138.png" alt="image-20240601133332138" style="zoom:80%;" />

<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p><img src="F:\Typora\img\image-20240601133434512.png" alt="image-20240601133434512" style="zoom:67%;" /><img src="F:\Typora\img\image-20240601133626307.png" alt="image-20240601133626307" style="zoom:67%;" /></p>
<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><img src="F:\Typora\img\image-20240601144659678.png" alt="image-20240601144659678" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601145123506.png" alt="image-20240601145123506" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601145247498.png" alt="image-20240601145247498" style="zoom:67%;" />

<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><img src="F:\Typora\img\image-20240601145827552.png" alt="image-20240601145827552" style="zoom:67%;" />

<p>单行可以用等于</p>
<img src="F:\Typora\img\image-20240601150346952.png" alt="image-20240601150346952" style="zoom:67%;" />

<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><img src="F:\Typora\img\image-20240601150445630.png" alt="image-20240601150445630" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601150644587.png" alt="image-20240601150644587" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601150846585.png" alt="image-20240601150846585" style="zoom:67%;" />



<img src="F:\Typora\img\image-20240601154143281.png" alt="image-20240601154143281" style="zoom:67%;" />



<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><img src="F:\Typora\img\image-20240601160424857.png" alt="image-20240601160424857" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601162759094.png" alt="image-20240601162759094" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601162856815.png" alt="image-20240601162856815" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601163336995.png" alt="image-20240601163336995" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601164944632.png" alt="image-20240601164944632" style="zoom:67%;" />

<p>mysql的默认是第三个，其他数据库不一定</p>
<img src="F:\Typora\img\image-20240601165108415.png" alt="image-20240601165108415" style="zoom:67%;" />

<p>事务隔离级别越高，数据越安全，但是性能越低</p>
<p>进阶篇</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>mysql的体系结构可以分为连接层，服务层，引擎层，存储层</p>
<img src="F:\Typora\img\image-20240601205309450.png" alt="image-20240601205309450" style="zoom:67%;" />

<p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型</p>
<p>一个数据库下的多张表可以选择不同的存储引擎</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><img src="F:\Typora\img\image-20240601210556613.png" alt="image-20240601210556613" style="zoom:67%;" />

<p>参数决定是多张表共享一个文件还是一张表一个文件，打开这个参数则代表一张表一个文件</p>
<p>8.0版本默认打开</p>
<p>innodb的逻辑存储结构</p>
<img src="F:\Typora\img\image-20240601211054598.png" alt="image-20240601211054598" style="zoom:67%;" />

<p>操作磁盘的最小单位是页</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><img src="F:\Typora\img\image-20240601211401510.png" alt="image-20240601211401510" style="zoom:67%;" />



<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><img src="F:\Typora\img\image-20240601211453249.png" alt="image-20240601211453249" style="zoom:67%;" />

<p>事务、外键、行级锁是InnoDB与MyISAM的主要区别</p>
<img src="F:\Typora\img\image-20240601211611812.png" alt="image-20240601211611812" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601211711773.png" alt="image-20240601211711773" style="zoom:67%;" />

<p>如日志数据适合使用MyISAM，但被MongoDB替代了</p>
<p>Memory则是被redis替代</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>帮助mysql高效获取数据的有序数据结构</p>
<img src="F:\Typora\img\image-20240601213335794.png" alt="image-20240601213335794" style="zoom:67%;" />

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><img src="F:\Typora\img\image-20240601213840932.png" alt="image-20240601213840932" style="zoom:67%;" />

<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><img src="F:\Typora\img\image-20240601213941726.png" alt="image-20240601213941726" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601214054141.png" alt="image-20240601214054141" style="zoom:67%;" />

<p>如果没有明确说明，一般都是B+tree索引</p>
<p>如果是二叉树的话，顺序插入时，会形成一个链表，查询性能大大降低，大数据量情况下，层级较深，检索速度慢。</p>
<p>红黑树的话，层级较深，检索速度慢。</p>
<img src="F:\Typora\img\image-20240601214711495.png" alt="image-20240601214711495" style="zoom:67%;" />

<p>B-Tree</p>
<img src="F:\Typora\img\image-20240601214651678.png" alt="image-20240601214651678" style="zoom:67%;" />

<p>B+Tree</p>
<img src="F:\Typora\img\image-20240601215530777.png" alt="image-20240601215530777" style="zoom:67%;" />

<p>所有元素都会出现在叶子结点</p>
<p>叶子结点形成了单向链表</p>
<img src="F:\Typora\img\image-20240601215846471.png" alt="image-20240601215846471" style="zoom:67%;" />

<p> hash</p>
<img src="F:\Typora\img\image-20240601220240703.png" alt="image-20240601220240703" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240601220258607.png" alt="image-20240601220258607" style="zoom:67%;" />

<p>为什么InnoDB存储引擎采用B+tree索引结构</p>
<img src="F:\Typora\img\image-20240601220639564.png" alt="image-20240601220639564" style="zoom:67%;" />

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><img src="F:\Typora\img\image-20240603103843691.png" alt="image-20240603103843691" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603104019415.png" alt="image-20240603104019415" style="zoom:67%;" />

<p>二级索引也可称为辅助索引或非聚集索引</p>
<img src="F:\Typora\img\image-20240603104315289.png" alt="image-20240603104315289" style="zoom:67%;" />

<p>使用二级索引会进行回表查询，两次查询</p>
<p>创建索引时，一个索引可以关联多个字段，如果关联一个字段称为单列索引，关联多个字段称为联合索引或者组合索引</p>
<img src="F:\Typora\img\image-20240603105947463.png" alt="image-20240603105947463" style="zoom:67%;" />

<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><img src="F:\Typora\img\image-20240603111223150.png" alt="image-20240603111223150" style="zoom:67%;" />

<p>Com后面是7个下划线</p>
<p>如果是以增删改为主的数据库，优化的比重就可以偏低</p>
<p>主要是优化以查询为主的数据库</p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><img src="F:\Typora\img\image-20240603111651380.png" alt="image-20240603111651380" style="zoom:67%;" />

<p>然后重启mysql即可完成配置</p>
<p>可通过慢查询日志来定位执行效率比较低的sql语句</p>
<p>慢查询是记录时长超过我们预设时间的sql语句</p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>如果是一些简单的sql语句，耗时较长但又没超过我们预设时间，我们也需要对它进行优化</p>
<p>该如何记录这些sql语句呢</p>
<img src="F:\Typora\img\image-20240603112727732.png" alt="image-20240603112727732" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603112753182.png" alt="image-20240603112753182" style="zoom:67%;" />

<p>以上都是通过耗费时间的长短来评判sql语句的性能，是粗略的判定</p>
<p>真正地评判sql语句的性能需根据sql语句的执行计划</p>
<h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><img src="F:\Typora\img\image-20240603113509786.png" alt="image-20240603113509786" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603130338815.png" alt="image-20240603130338815" style="zoom:67%;" />

<p>对于第三个类型</p>
<p>一般不可能为null，只有不访问数据库表才为null</p>
<p>访问系统表为system</p>
<p>使用到了主键索引、唯一索引为const</p>
<p>使用了非唯一索引则为ref</p>
<p>all是最差的情况，全表扫描</p>
<img src="F:\Typora\img\image-20240603130742853.png" alt="image-20240603130742853" style="zoom:67%;" />

<p>extea字段是额外信息的字段</p>
<h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><p>索引可以提高查询效率 </p>
<img src="F:\Typora\img\image-20240603132006525.png" alt="image-20240603132006525" style="zoom:67%;" />

<p>查询时位置可以随意，但联合索引中最左边的列一定要存在，如果跳跃了中间列，那么后面的所有将失效</p>
<img src="F:\Typora\img\image-20240603133107458.png" alt="image-20240603133107458" style="zoom:67%;" />

<p>但大于等于，小于等于则不会使右侧的列索引失效</p>
<img src="F:\Typora\img\image-20240603133507479.png" alt="image-20240603133507479" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603133708911.png" alt="image-20240603133708911" style="zoom:67%;" />

<p>字符串不加单引号，可以查询但索引会失效</p>
<img src="F:\Typora\img\image-20240603133748526.png" alt="image-20240603133748526" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603134030144.png" alt="image-20240603134030144" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603134632512.png" alt="image-20240603134632512" style="zoom:67%;" />

<p>大概就是如果大部分数据都满足查询条件，就不走索引了</p>
<p>如果少部分满足，就走索引</p>
<p>SQL提示</p>
<img src="F:\Typora\img\image-20240603150740630.png" alt="image-20240603150740630" style="zoom:67%;" />

<p> use是建议</p>
<p>ignore是忽略</p>
<p>force是必须</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><img src="F:\Typora\img\image-20240603151741577.png" alt="image-20240603151741577" style="zoom:67%;" />

<p>出现null也是需要回表查询</p>
<img src="F:\Typora\img\image-20240603152349463.png" alt="image-20240603152349463" style="zoom:67%;" />

<p>因为id是主键，所以根据username和password建立一个联合索引即可一次查询就得到所有结果</p>
<p>前缀索引</p>
<p>单个数据的体积量大可能会导致索引也很大，常用于对大文本建立索引时，采用前缀索引</p>
<img src="F:\Typora\img\image-20240603152721269.png" alt="image-20240603152721269" style="zoom:67%;" />



<p>单列索引和联合索引的选择，推荐使用联合，性能高且使用得当可以避免回表</p>
<img src="F:\Typora\img\image-20240603154506742.png" alt="image-20240603154506742" style="zoom:67%;" />

<p>多条件联合查询时，mysql优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询，并不是所有的索引都会用到。</p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><img src="F:\Typora\img\image-20240603155236168.png" alt="image-20240603155236168" style="zoom:67%;" />



<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><p>不要一条一条插入，建议批量插入，但不建议超过1000条</p>
<p>手动提交事务</p>
<p>主键顺序插入</p>
<img src="F:\Typora\img\image-20240603163250389.png" alt="image-20240603163250389" style="zoom:67%;" />

<p>主键顺序插入性能高于乱序插入</p>
<p>如果一次性插入大批量数据，不用使用insert，使用load指令</p>
<img src="F:\Typora\img\image-20240603163449884.png" alt="image-20240603163449884" style="zoom:67%;" />





<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><img src="F:\Typora\img\image-20240603164821849.png" alt="image-20240603164821849" style="zoom:67%;" />

<p>主键如果乱序插入的话，当数据满了时，会导致页分裂，即页的数据会在中间进行分裂，一页会被分裂为两页，然后插入新的数据并且重新进行指针的指向</p>
<img src="F:\Typora\img\image-20240603170110285.png" alt="image-20240603170110285" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603170236266.png" alt="image-20240603170236266" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603170424931.png" alt="image-20240603170424931" style="zoom:67%;" />



<h3 id="orderby优化"><a href="#orderby优化" class="headerlink" title="orderby优化"></a>orderby优化</h3><img src="F:\Typora\img\image-20240603170822327.png" alt="image-20240603170822327" style="zoom:67%;" />

<p>若使用了联合索引，当都是升序或者降序时，是using index的形式</p>
<p>但如果存在有的升序，有的降序的话，就会出现使用using filesort的情况，此时应针对这样子的情况创建索引，在创建索引时指定升序或降序</p>
<p>原因是在b+tree中存储顺序不一样</p>
<img src="F:\Typora\img\image-20240603172042304.png" alt="image-20240603172042304" style="zoom:67%;" />



<h3 id="groupby优化"><a href="#groupby优化" class="headerlink" title="groupby优化"></a>groupby优化</h3><p>在分组时，可以通过索引来提高效率</p>
<p>分组操作时，索引的使用也是满足最左前缀法则的</p>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在大数据量的情况下，越往后效率越低</p>
<p>可通过覆盖索引+子查询的方式进行优化</p>
<img src="F:\Typora\img\image-20240603191633093.png" alt="image-20240603191633093" style="zoom:67%;" />



<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><img src="F:\Typora\img\image-20240603191837845.png" alt="image-20240603191837845" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603191914699.png" alt="image-20240603191914699" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603192444650.png" alt="image-20240603192444650" style="zoom:67%;" />



<h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>在执行update语句的时候要根据索引进行更新，此时锁是行锁</p>
<p>如果更新是where条件不是索引字段，那么锁是表锁，会导致其他并发事务无法更新，降低并发性能</p>
<img src="F:\Typora\img\image-20240603201052103.png" alt="image-20240603201052103" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240603201925042.png" alt="image-20240603201925042" style="zoom:67%;" />







<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><img src="F:\Typora\img\image-20240604151656508.png" alt="image-20240604151656508" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240604152606515.png" alt="image-20240604152606515" style="zoom:67%;" />









































<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>java虚拟机</p>
<p>初始jvm</p>
<p>jvm是一个运行在计算机上的程序，职责是运行java字节码文件  </p>
<img src="F:\Typora\img\image-20240315215321693.png" alt="image-20240315215321693" style="zoom:67%;" />

<p>jvm解释出来的机器码就可以交给计算机运行了</p>
<h2 id="jvm的功能"><a href="#jvm的功能" class="headerlink" title="jvm的功能"></a>jvm的功能</h2><p>解释和运行，内存管理，即时编译</p>
<img src="F:\Typora\img\image-20240315215506241.png" alt="image-20240315215506241" style="zoom:67%;" />

<p>java如果不做任何优化，性能不如c，c++</p>
<p>因为java是解释性语言，但需要实时解释，这主要是为了跨平台特性</p>
<p>jvm是跨平台的，但不同的平台需要安装不同的jdk，因为他们的解释器是不一样的</p>
<p>而其他两个是编译性语言，性能很好</p>
<p>因此，为了提高java的性能，采取了将热点代码解释并优化，然后保存到内存中的方式来提高性能</p>
<img src="F:\Typora\img\image-20240315215939246.png" alt="image-20240315215939246" style="zoom:67%;" />

<h2 id="常见的jvm"><a href="#常见的jvm" class="headerlink" title="常见的jvm"></a>常见的jvm</h2><p><img src="F:\Typora\img\image-20240315220034865.png" alt="image-20240315220034865"></p>
<p>制作jvm同样是有规范的</p>
<img src="F:\Typora\img\image-20240315220309830.png" alt="image-20240315220309830" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240315221201762.png" alt="image-20240315221201762" style="zoom:67%;" />

<h2 id="java虚拟机的组成"><a href="#java虚拟机的组成" class="headerlink" title="java虚拟机的组成"></a>java虚拟机的组成</h2><p>类加载器：加载class字节码文件中的内容到内存中</p>
<p>运行时数据区域：即jvm管理的内存，负责管理jvm使用到的内存，比如创建对象和销毁对象</p>
<p>执行引擎（即时编译器，解释器，垃圾回收器等）：当字节码文件加载到内存后，将字节码文件中的指令解释成机器码，同时使用即时编译器优化性能，如果对象不使用了，则用垃圾回收器回收对象</p>
<p>本地接口：调用本地已经编译的方法，比如虚拟机中提供的c&#x2F;c++方法，同时本地接口需要时也会创建对象</p>
<img src="F:\Typora\img\image-20240315221917888.png" alt="image-20240315221917888" style="zoom:67%;" />



<p>类加载器：加载class字节码文件中的内容到内存中</p>
<p>运行时数据区域：负责管理jvm使用到的内存，比如创建对象和销毁对象</p>
<p>执行引擎：将字节码中的指令解释成机器码，同时使用即时编译器优化性能</p>
<p>先学类加载器，运行时数据区域以及垃圾回收器</p>
<p>在原理篇学习即时编译器</p>
<p>解释器和本地接口无法修改</p>
<h2 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h2><p>无法使用notepad++和记事本查看字节码文件</p>
<p>推荐使用jclasslib软件</p>
<p>idea好像有插件</p>
<img src="F:\Typora\img\image-20240315222542581.png" alt="image-20240315222542581" style="zoom:67%;" />

<p>字节码文件包含五部分内容</p>
<img src="F:\Typora\img\image-20240605211629090.png" alt="image-20240605211629090" style="zoom:67%;" />

<h3 id="基础信息："><a href="#基础信息：" class="headerlink" title="基础信息："></a>基础信息：</h3><p>魔数，字节码文件对应的java版本号，访问标识（public final等等），包含父类和接口，在jclasslib软件中被拆分为一般信息和接口</p>
<img src="F:\Typora\img\image-20240316232848105.png" alt="image-20240316232848105" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240316233151242.png" alt="image-20240316233151242" style="zoom:67%;" />

<p>一个经典的报错信息，类文件版本错误</p>
<img src="F:\Typora\img\image-20240316233246782.png" alt="image-20240316233246782" style="zoom:67%;" />

<p>这个信息是需要的版本是jdk1.8，而你的环境是jdk1.6</p>
<p>低版本无法加载高版本文件</p>
<p>两种解决方案</p>
<p>1、升级jdk版本</p>
<p>2、解决第三方依赖的版本号，或者更换依赖</p>
<img src="F:\Typora\img\image-20240316235707376.png" alt="image-20240316235707376" style="zoom:67%;" />





<h3 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h3><p>避免相同的内容重复定义，节省空间</p>
<p>保存了字符串常量、类或接口名，字段名，主要在字节码指令中使用</p>
<p>一个字符串，有名字和值，如果常量池里有该字符串的名字和值，则直接指向对应的位置，否则先指向String的位置，再指向对应的位置？？？</p>
<h3 id="字段："><a href="#字段：" class="headerlink" title="字段："></a>字段：</h3><p>当前类或接口声明的字段信息</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>当前类或接口声明的方法信息，字节码指令</p>
<img src="F:\Typora\img\image-20240317002514514.png" alt="image-20240317002514514" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240317002832613.png" alt="image-20240317002832613" style="zoom:67%;" />

<p>数组下标为0的位置是存放args的</p>
<p>i的下标是1，j的下标是2，是因为声明顺序是i先的</p>
<p>iconst指令是将其后面的数放入操作数栈，操作数栈可以认为是一个栈，可以放多个数据</p>
<p>istore指令是将操作数栈中的数据取出来并放入局部变量表中对应的位置</p>
<p>iload指令是将局部变量表中对应的位置是数据复制一份到操作数栈中</p>
<p>iadd就是将操作数栈顶部的两个数据弹出相加，结果重新放入栈中</p>
<img src="F:\Typora\img\image-20240317004025437.png" alt="image-20240317004025437" style="zoom:67%;" />



<h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><p>类的属性，比如源码的文件名，内部类的列表等</p>
<h2 id="字节码文件常见工具"><a href="#字节码文件常见工具" class="headerlink" title="字节码文件常见工具"></a>字节码文件常见工具</h2><p>javap -v命令 是在linux操作的看，windows不知道可不可以，</p>
<img src="F:\Typora\img\image-20240317213731154.png" alt="image-20240317213731154" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240317214056655.png" alt="image-20240317214056655" style="zoom:67%;" />

<p><img src="F:\Typora\img\image-20240318160848463.png" alt="image-20240318160848463"></p>
<p>这个是一个jar包</p>
<p>如果要启动需要在命令台窗口使用java -jar  xxx.jar启动</p>
<p>然后会显示目前运行的java进程</p>
<p>输入对应进程前面的下标序号和回车就进入该进程程序的内部</p>
<img src="F:\Typora\img\image-20240318160632902.png" alt="image-20240318160632902" style="zoom:67%;" />

<p>我们可以通过官方文档来了解Arthas</p>
<h3 id="Arthas常用命令"><a href="#Arthas常用命令" class="headerlink" title="Arthas常用命令"></a>Arthas常用命令</h3><h4 id="dashboard-命令"><a href="#dashboard-命令" class="headerlink" title="dashboard 命令"></a>dashboard 命令</h4><p>查看数据面板窗口 dashboard -i 2000 -n 3</p>
<img src="F:\Typora\img\image-20240318161900991.png" alt="image-20240318161900991" style="zoom:67%;" />

<p>-i ：加上数字表示每隔多少毫秒刷新一次</p>
<p>-n ： 表示总共刷新几次</p>
<h4 id="dump-命令"><a href="#dump-命令" class="headerlink" title="dump 命令"></a>dump 命令</h4><p>加载类的字节码文件到特定目录 如 dump -d xxx (地址) xxx(包名.类名)</p>
<img src="F:\Typora\img\image-20240318161951674.png" alt="image-20240318161951674" style="zoom:67%;" />



<h4 id="jad命令"><a href="#jad命令" class="headerlink" title="jad命令"></a>jad命令</h4><p>反编译已加载类的源码 jad xxx(包名.类名)</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><img src="F:\Typora\img\image-20240318163927003.png" alt="image-20240318163927003" style="zoom:67%;" />

<h3 id="生命周期概述"><a href="#生命周期概述" class="headerlink" title="生命周期概述"></a>生命周期概述</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>1、加载阶段的第一步是<strong>类加载器</strong>会根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息</p>
<p>常见渠道有，读取磁盘上的字节码文件，程序运行时使用动态代理生成，通过网络传输的类</p>
<p>程序员可以使用java代码拓展不同的渠道，如需要将类保存到数据库进行持久化，就可以在这一步处理</p>
<p>2、类加载器在加载完类之后，java虚拟机会将字节码中的信息保存到内存的方法区中</p>
<p>方法区是一个虚拟概念，不同jvm的方法区是不同的</p>
<p>3、java虚拟机收集到字节码信息之后，会生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息</p>
<img src="F:\Typora\img\image-20240318165027666.png" alt="image-20240318165027666" style="zoom:67%;" />

<p>4、同时java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象，作用是在java代码中去获取类的信息以及<strong>存储静态字段的数据（jdk8及以后）</strong>，静态字段jdk8以前放在方法区</p>
<img src="F:\Typora\img\image-20240318165441428.png" alt="image-20240318165441428" style="zoom:67%;" />

<p>为什么保存两个对象而不是一个方法区中对象呢？</p>
<p>因为方法区中的对象一般是c++编写的，java程序员不能直接操作</p>
<p>而堆区中的对象是java语言包装的，同时该区的方法字段要少于方法区的字段方法</p>
<p>InstanceKlass中的方法字段，java开发者并不是都需要使用到</p>
<p>我们将开发者需要的数据保存到堆区中，可以控制访问的数据范围</p>
<img src="F:\Typora\img\image-20240318165949869.png" alt="image-20240318165949869" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318170016095.png" alt="image-20240318170016095" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318170038423.png" alt="image-20240318170038423" style="zoom:67%;" />

<p>使用这个工具查看某个java进程程序的内存信息，需要对应的进程id</p>
<p>在lib目录下的命口窗口使用命令</p>
<p>可以利用jps命令查看所以的java进程，以及对应的进程id</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>可分为三部分</p>
<p>第一阶段是验证，验证内容是否满足《java虚拟机规范》，一般不需要程序员参与</p>
<p>包含四部分</p>
<p>1、文件格式验证，魔数是否正确以及主次版本号是否满足当前java虚拟机版本要求</p>
<p>2、元信息验证，例如类必须有父类</p>
<p>3、验证程序执行指令的语义是否正确</p>
<p>4、符号引用验证，例如是否访问了其他类中private的方法</p>
<img src="F:\Typora\img\image-20240318183747879.png" alt="image-20240318183747879" style="zoom:67%;" />



<p>第二阶段是准备，给静态变量分配内存并赋初值</p>
<p>如果是static修饰的则赋初始值</p>
<img src="F:\Typora\img\image-20240318185309105.png" alt="image-20240318185309105" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318185001994.png" alt="image-20240318185001994" style="zoom:67%;" />

<p>为什么要赋初始值呢</p>
<p>防止有随机值</p>
<p>但如果还有final修饰，则直接赋值</p>
<img src="F:\Typora\img\image-20240318185328034.png" alt="image-20240318185328034" style="zoom:67%;" />



<p>第三阶段是解析，将常量池中的符号引用替换成指向内存的直接引用</p>
<p>符合引用就是在字节码文件中使用编号来访问常量池中的内容</p>
<p>如这里的cp…#6就是符号引用</p>
<img src="F:\Typora\img\image-20240318185642690.png" alt="image-20240318185642690" style="zoom:67%;" />

<p>直接引用不再使用编号，而是使用内存中地址进行访问具体的数据</p>
<p>替换为使用内存的方式的直接引用</p>
<img src="F:\Typora\img\image-20240318185808541.png" alt="image-20240318185808541" style="zoom:67%;" />



<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段会执行<strong>静态代码块</strong>中的代码，并为<strong>静态变量</strong>赋值</p>
<p>static的赋值就是此完成</p>
<p>初始化阶段会执行字节码文件中clinit部分的字节码指令</p>
<img src="F:\Typora\img\image-20240318195824510.png" alt="image-20240318195824510" style="zoom:50%;" />

<img src="F:\Typora\img\image-20240318201127902.png" alt="image-20240318201127902" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318201237007.png" alt="image-20240318201237007" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318201619663.png" alt="image-20240318201619663" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318201659521.png" alt="image-20240318201659521" style="zoom:67%;" />

<p>访问父类的静态变量，不需要初始化子类，访问子类的静态变量，一定会初始化父类</p>
<img src="F:\Typora\img\image-20240318201853172.png" alt="image-20240318201853172" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240318201924079.png" alt="image-20240318201924079" style="zoom:67%;" />









<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><img src="F:\Typora\img\image-20240324164515164.png" alt="image-20240324164515164" style="zoom:67%;" />



<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><img src="F:\Typora\img\image-20240401085141448.png" alt="image-20240401085141448" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240401085610008.png" alt="image-20240401085610008" style="zoom:67%;" />



<p>虚拟机的了解即可，java中实现才是需要关注的</p>
<img src="F:\Typora\img\image-20240401085927579.png" alt="image-20240401085927579" style="zoom:67%;" />

<p>启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器</p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>如果获取一个类加载器，在输出时返回null，则可能是启动类加载器</p>
<p>核心，重要的类文件</p>
<p>此处是额外添加启动类加载器，只需要添加自己的目录</p>
<img src="F:\Typora\img\image-20240401091330123.png" alt="image-20240401091330123" style="zoom:67%;" />

<h3 id="java中的类加载器"><a href="#java中的类加载器" class="headerlink" title="java中的类加载器"></a>java中的类加载器</h3><img src="F:\Typora\img\image-20240401093430185.png" alt="image-20240401093430185" style="zoom:67%;" />

<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>通用但是不重要的类文件</p>
<p>此处是覆盖，这里填写参数时需要输入原来的ext目录以及你自己新添加的目录</p>
<img src="F:\Typora\img\image-20240401092651719.png" alt="image-20240401092651719" style="zoom:67%;" />

<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p>加载classpath下的类文件，包括我们自己编写的类和接口以及第三方jar包中的类和接口文件</p>
<p>但是加载应用程序类加载器的时候，又加载了启动类加载器和扩展类加载器，这就涉及到了双亲委派机制</p>
<h3 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h3><p>由于java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题</p>
<p>作用</p>
<img src="F:\Typora\img\image-20240402105432082.png" alt="image-20240402105432082" style="zoom:60%;" />



<img src="F:\Typora\img\image-20240402105722711.png" alt="image-20240402105722711" style="zoom:67%;" />

 <img src="F:\Typora\img\image-20240402105746671.png" alt="image-20240402105746671" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402105956377.png" alt="image-20240402105956377" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402110023040.png" alt="image-20240402110023040" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402110057076.png" alt="image-20240402110057076" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402110111937.png" alt="image-20240402110111937" style="zoom:67%;" />

<p>优先由启动类加载器加载，加载不了则交给扩展类加载器，最后才交给应用程序类加载器加载</p>
<img src="F:\Typora\img\image-20240402111331962.png" alt="image-20240402111331962" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402111631349.png" alt="image-20240402111631349" style="zoom:67%;" />

<p>如果在加载过程中，三个类加载器都无法成功就按照加载某个类，就会抛出类无法找到的错误</p>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><h4 id="为何要打破？"><a href="#为何要打破？" class="headerlink" title="为何要打破？"></a>为何要打破？</h4><p>如果两个应用中出现了多个相同限定名的类，因为双亲委派机制的原因，只会加载一次</p>
<p>导致应用2及以后的类就无法被加载了</p>
<p>此时可以使用自定义类加载器来实现应用之间的隔离，每一个应用会有一个独立的类加载器加载对应的类</p>
<h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4><img src="F:\Typora\img\image-20240402112640406.png" alt="image-20240402112640406" style="zoom:67%;" />

<p>方法一：自定义类加载器</p>
<img src="F:\Typora\img\image-20240402113752558.png" alt="image-20240402113752558" style="zoom:67%;" />

<p>编写自定义类加载器时，如果没有手动指明父类，则默认父类是应用程序类加载器</p>
<img src="F:\Typora\img\image-20240402121106709.png" alt="image-20240402121106709" style="zoom:67%;" />

<p>方法二：不懂</p>
<p>获取线程上下文中保存的类加载器，默认就是应用程序类加载器</p>
<p>就是JDBC的DriverManager类在rt.jar包内, 由启动类加载器加载, 驱动的全限定名通过spi来获取,但加载驱动没法通过启动类加载器,因为不在其加载路径内</p>
<p>方法三：不懂</p>
<h3 id="jdk8以后的类加载器"><a href="#jdk8以后的类加载器" class="headerlink" title="jdk8以后的类加载器"></a>jdk8以后的类加载器</h3><img src="F:\Typora\img\image-20240402130706147.png" alt="image-20240402130706147" style="zoom:67%;" />



<img src="F:\Typora\img\image-20240402130842307.png" alt="image-20240402130842307" style="zoom:67%;" />

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="F:\Typora\img\image-20240402130951241.png" alt="image-20240402130951241" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402131010115.png" alt="image-20240402131010115" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402131110291.png" alt="image-20240402131110291" style="zoom:67%;" />

<img src="F:\Typora\img\image-20240402131255472.png" alt="image-20240402131255472" style="zoom:67%;" />







































































  













</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2024/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/29/cloud/" title="cloud"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">cloud</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">快捷键使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">创建链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">栈的经典应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">经典应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">2.3.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">朴素模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">kmp算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">串的前缀和后缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next%E6%95%B0%E7%BB%84%E4%B8%8Ekmp%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">next数组与kmp算法代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82next%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">求next数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">next数组的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.4.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.3.</span> <span class="toc-text">树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.2.</span> <span class="toc-text">特殊二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B8%B8%E8%80%83%E6%80%A7%E8%B4%A8"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">二叉树的常考性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B8%B8%E8%80%83%E6%80%A7%E8%B4%A8"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">完全二叉树的常考性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.4.</span> <span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.5.</span> <span class="toc-text">先中后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.6.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.7.</span> <span class="toc-text">线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.</span> <span class="toc-text">内部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">交换排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">外部排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.8.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">2.9.</span> <span class="toc-text">特殊矩阵的压缩存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">蓝桥杯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.1.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%A5%87%E5%81%B6%E6%95%B0"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">判断奇偶数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%BD%8D%E6%98%AF1%E8%BF%98%E6%98%AF0%EF%BC%8C"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">判断某位是1还是0，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">交换两个整数变量的值，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B4%E6%95%B0%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">判断整数的绝对值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%981%EF%BC%9A%E6%89%BE%E5%94%AF%E4%B8%80%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">题1：找唯一重复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%982%EF%BC%9A%E6%89%BE%E5%87%BA%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0"><span class="toc-number">3.1.3.</span> <span class="toc-text">题2：找出落单的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%983%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">题3：二进制中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%984%EF%BC%9A%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">3.1.5.</span> <span class="toc-text">题4：整数是否为2的整数次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%985%EF%BC%9A%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E5%81%B6%E4%BD%8D%E4%BA%92%E6%8D%A2"><span class="toc-number">3.1.6.</span> <span class="toc-text">题5：整数二进制奇偶位互换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%986%EF%BC%9A0-1%E9%97%B4%E6%B5%AE%E7%82%B9%E5%AE%9E%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">3.1.7.</span> <span class="toc-text">题6：0~1间浮点实数的二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%987%EF%BC%9A%E5%87%BA%E7%8E%B0k%E6%AC%A1%E4%B8%8E%E5%87%BA%E7%8E%B01%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="toc-number">3.1.8.</span> <span class="toc-text">题7：出现k次与出现1次的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%A4%96%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.1.9.</span> <span class="toc-text">课外作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-number">3.2.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">基础练习例题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82n%E7%9A%84%E9%98%B6%E4%B9%98"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">求n的阶乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0i-j"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">打印i-j</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">数组求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">翻转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">最大公约数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%94%B9%E4%B8%BA%E9%80%92%E5%BD%92"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">插入排序改为递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="toc-number">3.2.1.8.</span> <span class="toc-text">汉诺塔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95"><span class="toc-number">3.2.1.9.</span> <span class="toc-text">二分查找递归解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.1.10.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="toc-number">3.3.</span> <span class="toc-text">分治思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5"><span class="toc-number">3.5.</span> <span class="toc-text">贪心策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.6.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Feign"><span class="toc-number">4.</span> <span class="toc-text">Feign</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">5.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.1.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.2.</span> <span class="toc-text">容器命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.3.</span> <span class="toc-text">数据卷命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">5.1.4.</span> <span class="toc-text">如何自定义镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose"><span class="toc-number">5.1.5.</span> <span class="toc-text">docker compose</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">6.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98"><span class="toc-number">6.1.</span> <span class="toc-text">Redis企业实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">黑马点评</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E4%BA%8Esession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">1、基于session实现登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%9C%A8session%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">redis在session中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">2、商户查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.1.1.5.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.1.1.6.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.1.1.7.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.1.1.8.</span> <span class="toc-text">利用互斥锁解决缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.1.1.9.</span> <span class="toc-text">利用逻辑过期解决缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="toc-number">6.1.1.10.</span> <span class="toc-text">缓存工具类封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">6.1.1.11.</span> <span class="toc-text">3、优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80id%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">6.1.1.11.1.</span> <span class="toc-text">全局id生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">6.1.1.11.2.</span> <span class="toc-text">秒杀下单</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.1.1.11.3.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">6.1.1.11.4.</span> <span class="toc-text">一人一单</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.1.1.12.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC"><span class="toc-number">6.1.1.12.1.</span> <span class="toc-text">初级版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.1.12.2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">6.1.1.12.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson"><span class="toc-number">6.1.1.13.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">6.1.1.13.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.1.13.2.</span> <span class="toc-text">可重入锁原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8Cwatchdog%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.1.13.3.</span> <span class="toc-text">锁重试和watchdog机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.1.1.13.4.</span> <span class="toc-text">主从一致性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">6.1.2.</span> <span class="toc-text">秒杀优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.1.3.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">6.1.4.</span> <span class="toc-text">达人探店</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">6.1.5.</span> <span class="toc-text">完善点赞功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">6.1.6.</span> <span class="toc-text">点赞排行榜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">6.1.7.</span> <span class="toc-text">好友关注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">6.1.8.</span> <span class="toc-text">关注推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.9.</span> <span class="toc-text">GEO数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">6.1.10.</span> <span class="toc-text">实现附近商户的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">6.1.11.</span> <span class="toc-text">签到功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">6.1.12.</span> <span class="toc-text">HyperLogLog</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ"><span class="toc-number">7.</span> <span class="toc-text">MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">7.1.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">入门案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">7.1.2.</span> <span class="toc-text">发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fanout-Exchange"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">Fanout Exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-Exchange"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">Direct Exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic-Exchange"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">Topic Exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">消息转换器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ"><span class="toc-number">7.2.</span> <span class="toc-text">RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#broker%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9C%BA"><span class="toc-number">7.2.2.</span> <span class="toc-text">broker的主从机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">7.2.3.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.4.</span> <span class="toc-text">消费模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.</span> <span class="toc-text">发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">同步消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">异步消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.3.</span> <span class="toc-text">单向消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.4.</span> <span class="toc-text">延迟消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.5.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.6.</span> <span class="toc-text">批量消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.5.7.</span> <span class="toc-text">事务消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tag%E8%BF%87%E6%BB%A4"><span class="toc-number">7.2.6.</span> <span class="toc-text">tag过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key"><span class="toc-number">7.2.7.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.8.</span> <span class="toc-text">重复消费问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E5%92%8C%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.9.</span> <span class="toc-text">消息重试和死信消息解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boot%E6%93%8D%E4%BD%9Cmq"><span class="toc-number">7.2.10.</span> <span class="toc-text">boot操作mq</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-1"><span class="toc-number">7.2.10.1.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.10.2.</span> <span class="toc-text">消费消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6tag"><span class="toc-number">7.2.10.3.</span> <span class="toc-text">携带tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6key"><span class="toc-number">7.2.10.4.</span> <span class="toc-text">携带key</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.11.</span> <span class="toc-text">消费的两种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.12.</span> <span class="toc-text">消费堆积问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%83%85%E5%86%B51%EF%BC%9A%E7%94%9F%E4%BA%A7%E9%80%9F%E5%BA%A6%E8%BF%9C%E8%BF%9C%E5%A4%A7%E4%BA%8E%E6%B6%88%E8%B4%B9%E9%80%9F%E5%BA%A6"><span class="toc-number">7.2.12.1.</span> <span class="toc-text">问题情况1：生产速度远远大于消费速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%83%85%E5%86%B52%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.12.2.</span> <span class="toc-text">问题情况2：消费者消费出现问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.2.13.</span> <span class="toc-text">如何确保消息不丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.14.</span> <span class="toc-text">安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rocketmq%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.15.</span> <span class="toc-text">rocketmq设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1"><span class="toc-number">7.2.16.</span> <span class="toc-text">秒杀业务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E8%BD%AF%E4%BB%B6%E6%96%B9%E9%9D%A2%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">7.2.16.1.</span> <span class="toc-text">如何从软件方面提高吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.16.2.</span> <span class="toc-text">秒杀流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web%E5%8F%91%E9%80%81%E4%B8%8B%E5%8D%95%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.16.3.</span> <span class="toc-text">web发送下单消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.16.4.</span> <span class="toc-text">秒杀服务消费消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">7.2.16.5.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">7.2.16.5.1.</span> <span class="toc-text">方案一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">7.2.16.5.2.</span> <span class="toc-text">方案二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.2.16.5.3.</span> <span class="toc-text">redis分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E6%80%BB%E7%BB%93"><span class="toc-number">7.2.17.</span> <span class="toc-text">秒杀总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Seata"><span class="toc-number">8.</span> <span class="toc-text">Seata</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gateway"><span class="toc-number">9.</span> <span class="toc-text">Gateway</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Elasticsearch"><span class="toc-number">10.</span> <span class="toc-text">Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">10.1.</span> <span class="toc-text">倒排索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">11.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%88%86%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">SQL分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDl"><span class="toc-number">11.1.1.</span> <span class="toc-text">DDl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML"><span class="toc-number">11.1.2.</span> <span class="toc-text">DML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DQL"><span class="toc-number">11.1.3.</span> <span class="toc-text">DQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.4.</span> <span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.1.5.</span> <span class="toc-text">分组查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.1.6.</span> <span class="toc-text">排序查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.1.7.</span> <span class="toc-text">分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.1.8.</span> <span class="toc-text">执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCL"><span class="toc-number">11.1.9.</span> <span class="toc-text">DCL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">数值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.3.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.4.</span> <span class="toc-text">流程函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">11.3.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.4.1.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.4.2.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.4.3.</span> <span class="toc-text">自连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.4.</span> <span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.5.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.5.1.</span> <span class="toc-text">标量子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.5.2.</span> <span class="toc-text">列子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.5.3.</span> <span class="toc-text">行子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.4.5.4.</span> <span class="toc-text">表子查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.5.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">11.6.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-number">11.6.1.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">11.6.2.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">11.6.3.</span> <span class="toc-text">Memory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">11.7.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">11.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.7.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">11.7.3.</span> <span class="toc-text">索引结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">11.7.4.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">11.7.5.</span> <span class="toc-text">SQL性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.7.6.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#profile"><span class="toc-number">11.7.7.</span> <span class="toc-text">profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain"><span class="toc-number">11.7.8.</span> <span class="toc-text">explain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">11.7.9.</span> <span class="toc-text">索引使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">11.7.10.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">11.7.11.</span> <span class="toc-text">索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#insert%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.1.</span> <span class="toc-text">insert优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.2.</span> <span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orderby%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.3.</span> <span class="toc-text">orderby优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#groupby%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.4.</span> <span class="toc-text">groupby优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.5.</span> <span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.6.</span> <span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96"><span class="toc-number">11.8.7.</span> <span class="toc-text">update优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">11.9.</span> <span class="toc-text">视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">12.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.</span> <span class="toc-text">jvm的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84jvm"><span class="toc-number">12.2.</span> <span class="toc-text">常见的jvm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">12.3.</span> <span class="toc-text">java虚拟机的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">12.4.</span> <span class="toc-text">字节码文件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">12.4.1.</span> <span class="toc-text">基础信息：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9A"><span class="toc-number">12.4.2.</span> <span class="toc-text">常量池：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-number">12.4.3.</span> <span class="toc-text">字段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">12.4.4.</span> <span class="toc-text">方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">12.4.5.</span> <span class="toc-text">属性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7"><span class="toc-number">12.5.</span> <span class="toc-text">字节码文件常见工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arthas%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">12.5.1.</span> <span class="toc-text">Arthas常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dashboard-%E5%91%BD%E4%BB%A4"><span class="toc-number">12.5.1.1.</span> <span class="toc-text">dashboard 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dump-%E5%91%BD%E4%BB%A4"><span class="toc-number">12.5.1.2.</span> <span class="toc-text">dump 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jad%E5%91%BD%E4%BB%A4"><span class="toc-number">12.5.1.3.</span> <span class="toc-text">jad命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.6.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">12.6.1.</span> <span class="toc-text">生命周期概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">12.6.1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.6.1.2.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">12.6.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">12.6.1.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">12.6.1.5.</span> <span class="toc-text">卸载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.2.</span> <span class="toc-text">java中的类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.3.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.4.</span> <span class="toc-text">应用程序类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">12.7.5.</span> <span class="toc-text">类加载器的双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">12.7.6.</span> <span class="toc-text">打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E6%89%93%E7%A0%B4%EF%BC%9F"><span class="toc-number">12.7.6.1.</span> <span class="toc-text">为何要打破？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">12.7.6.2.</span> <span class="toc-text">三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E4%BB%A5%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">12.7.7.</span> <span class="toc-text">jdk8以后的类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.7.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="学习笔记">学习笔记</a><time datetime="2024-05-30T10:00:00.000Z" title="Created 2024-05-30 18:00:00">2024-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/29/cloud/" title="cloud">cloud</a><time datetime="2024-05-29T10:00:00.000Z" title="Created 2024-05-29 18:00:00">2024-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/07/hello-world/" title="Hello World">Hello World</a><time datetime="2024-05-07T10:44:14.832Z" title="Created 2024-05-07 18:44:14">2024-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>